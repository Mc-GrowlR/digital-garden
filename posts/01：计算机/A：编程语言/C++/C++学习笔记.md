---
title: 
uid: 202205142244
aliases: []
tags: [C++]
from: 
editflag: 0
---

***
# 学习
#Cpp  #c--   #c++

《C++ Primer Plus》对于新手真的很友好。

不要让别人的错误，来让自己买单。

C++的语法过于庞杂，颗粒度细，在初学的时候很记住。

> 最好的方法是在我们自己开发的C++程序中使用其中的新特性

>轻松地使用这种语言。不要觉得必须使用所有的特性，不要在第一次学习时就试图使用所有的特性。

>不要为不使用的特性付出代价

还有一件事，磨刀不误砍柴工。

C++中的概念纷繁复杂，学习时一定要加以梳理。

知识体系与学习体系往往是相反的。

# C++ 基本语法描述
- 每条语句占一行，每条语句以终止符（分号）结束
- 一行代码中不可分割的元素叫做标记（token），必须要用空格、制表符和回车将两个标记分开。空格、制表符和回车成为空白（white space)
- 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行
- 函数中的语句都相对于花括号进行缩进
- 与函数名称相关的圆括号周围没有空白
- C++ 程序是一组函数，而每个函数又是一组语句。
C++程序由一个或多个被称为函数的模块组成。

预处理器编译指令`#include`

C++语句类型：
- 声明语句
- 赋值语句
- 消息语句
- 函数调用
- 函数原型
- 返回语句
## 声明语句
程序中的声明语句叫做定义声明（defining declaration），简称定义（declaration）
使用声明语句来指出储存类型并提供位置标签。
声明语句提供了两种信息：需要的内存以及该内存单元的名称。而编译器负责分配和标记内存细节。所有的变量都需要声明。
声明通产指出了要存储的数据类型和程序对储存在这里的数据使用的名称，这意味着它将导致编译器为变量分配内存空间。
除了定义声明外，还有引用声明（命令计算机使用在其他地方定义的变量）
通常，声明不一定是定义。
对于声明变量，尽量在首次使用前声明。

## 赋值语句
赋值语句将值赋给储存单元
符号= 叫做赋值运算符。赋值运算符可以连续使用，在此时，赋值将从右向左进行。（P20）

### 函数

有无返回值都叫函数

### using 编译指令

- 将 `using namespace std;`放在函数定义之前，让文件中所有的函数都能够使用名称空间std中所有的元素。
- 将 `using namespace std;`放在特定的函数定义中，让该函数能够使用名称空间`std`种的所有元素。
- 在特定的函数种使用类似`using std::cout;`这样的编译指令，而不是`using namespace std;`   ，让该函数能够使用特定的元素，如`cout`。
- 完全不使用编译指令`using`而在需要使用std中的元素时，使用前缀`std::`

编译指令 using namespace
***
# 输入输出

``<<``  插入运算符
`>>`  抽取运算符
用于处理输入输出的预定义对象（cin和cout）是istream和ostream的实例。


标记间的换行符和空格看作是可相互替换的。针对语句过长时（P22）

`cout`会删除==结尾==的零。

### cin 

cin使用空白来确定字符串的结束位置，并在字符串结尾自动添加空字符。
#### cin类成员函数
|函数|功能|
|:-:|:-:|
|getline(s1,ArSize)|读取一行输入，直到换行符。随后丢弃换行符.|
|get(s1,ArSize)|读取一行输入，直到换行符。并将换行符留在输入队列中|
|clear()|清除之前输入错误产生的错误状态。|
### cout
#### cout控制符
控制符位于名称空间`std`中不能用作变量名。
- `endl`控制换行
- `dec`控制以十进制格式显示整数
- `hex`以十六进制格式显示整数
- `oct`以八进制格式显示整数

#### cout成员函数。
1. `cout.put()`
   该函数显示一个字符
2. `cout.setf()`
   迫使输出使用定点表示法，会覆盖掉`cout`会删除==结尾==的零的行为。
   参数：`ios_base::fixed`(将对象置于使用顶点表示法的模式)、`ios_base::floatfield`(将对象至于显示小数点的模式，即使小数部分为零。)、`ios_base::booaplpha`(设置一个标记，该标记命令cout显示true和false而不是0和1)
3. `width()`
   设置下一次输出操作使用的字符宽度，这种设置只在显示下一个值时有效，然后将恢复到默认设置。默认的字符宽度为零，意味着正好容纳下要显示的内容。



## 文本输入、输出

### 文本输出

输入一开始都是字符数据（文本数据），然后cin对象负责将文本转换为其他类型。

源代码文件就属于文本文件。

必须包含头文件 ` fstream`，然后声明自己的` ofstream`对象（最少一个）

使用文件输出的主要步骤：

1. 包含头文件fstream
2. 创建一个ofstream对象
3. 将该ofstream对象同一个个文件关联起来。
4. 就像cout那样使用该ofstream对象。
5. 使用后关闭文件。



声明格式：

~~~ cpp
ofstream outFile;
ofstream fout;
~~~

然后将这种对象与特定的文件关联起来：

~~~ cpp
outFile.open("fish.txt");
char filename[50];
cin>>filename;
fout.open(filename);
~~~

方法open接受一个C风格字符串作为参数，这也可以是一个字符串，也可以是储存在数组中的字符串。

声明一个ofstream对象并将其同文件管来拿起来之后，便可以像使用cout那样使用它。

所有的可用于cout的操作和方法（如<<、endl和setf()）都可以用于ofstream对象。

程序使用完该文件后，应该将其关闭

~~~ cpp 
outFile.close();
~~~

方法不需要使用close()不需要使用文件名作为参数，因为outFile已将同特定的文件关联起来。

如果没关闭文件。在程序结束时，程序正常终止时将自动关闭它。

注意：在默认情况下，如果文件名已存在，open()方法将首先截断该文件，既将其长度截断到零——丢弃原有的内容，然后将新的输出加到该文件中。



### 文本输入

必须包含头文件`fstream`

必须声明自己的ifstream对象

~~~ cpp
ifstream infile;
ifstream fin;
~~~

将对象与特定的文件关联起来

~~~ cpp
infile.open("fish.txt");
char filename[50];
cin>>filename;
fin.open(filename);
~~~

方法open()接受一个C风格字符串作为参数，可以是一个字面字符串，也可以是储存在数组中的字符串。



如果试图打开一个不存在的文件用于输入，这种错误将导致ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用is_open()。

~~~ cpp
infile.open("bowling.txt");
if (!infile.is_open())
{
    exit(EXIT_FAILURE);
}
~~~

如果文件成功的被打开，方法is_open()将返回true

函数`exit()`的原型实在头文件`cstdlib`中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值`EXIT_FAILURE`。

函数exit()终止程序。

windows文本文件都以回车字符和换行字符结尾。通常情况下，C++在读取文件时将这两个字符转换为换行符，并在写入文件是执行相反的操作，

~~~ cpp 
#include<iostream>
#include<fstream>
#include<cstdlib>
#include<ctime>
const int SIZE = 60;
int main()
{
	using namespace std;
	char filename[SIZE];
	ifstream inFile;
	cout << "Enter name of data file: ";
	cin.getline(filename,SIZE);
	inFile.open(filename);
	if (!inFile.is_open())
	{
		cout << "Could  not open the file " << filename << endl;
		cout << "Program terminating.\n";
		exit(EXIT_FAILURE);
	}
	double value;
	double sum = 0.0;
	int count = 0;

	inFile >> value;
	while (inFile.good())
	{
		++count;
		sum += value;
		inFile >> value;
	}
	if (inFile.good())
	{
		cout << "End of file reached.\n";
	}
	else if (inFile.fail())
	{
		cout << "Input terminated by data mismatch.\n";
	}
	else
	{
		cout << "Input terminated for unknown reason.\n";
	}
	if (count == 0)
		cout << "No data processed.\n";
	else
	{
		cout << "Items read: " << count << endl;
		cout << "Sum: " << sum << endl;
		cout << "Average:" << sum / count << endl;
	}
	inFile.close();
	return 0;
}
~~~

**注意**检查文件是否被打开至关重要。

注意：应特别注意文件读取循环的正确设计。

- 程序读取文件不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()将返回true

- 在读取时，要注意类型需匹配。如果最后一次读取操作中发生了类型不匹配，方法fail()将返回true（EOF也返回true）。

- 可能会出现以外的问题。如文件受损或硬件故障。如果最后一次读取文件发生了这样的问题，方法bad()将返回true。

- 可以采用good()方法一并检测上述问题。没有错误时返回true。方法good()指出最后一次读取输入的操作是否成功。
  ~~~ cpp
  while (inFile.good())
  {
      body
  }
  ~~~

分步检测出错误原因：
~~~ cpp
if (inFile.eof())//判断是否到达了eof
    cout<<"End of file reached.\n";
else if (inFile.faail())/判断是否是类型不匹配
    cout<<"Input terminated by data misamatch.\n";
else 
    cout<<"Input terminated for unknown reason.\n";
~~~

分步检测代码跟在循环的后面，用于判断循环为何终止。

可以将两条输入语句用一条用作循环测试的输入语句代替。，用来代替good()方法检测。

~~~ cpp
while (inFile >> value)
{
    //循环体
    //跳出循环条件
}
~~~



***
# 数据类型
  面向对象编程（OOP）的本质是设计并拓展自己的数据类型。设计自己的数据类型是让类型与数据匹配
内置的C++类型分为两组：==基本类型==和==复合类型==。
其中，基本类型分为==整形==和==浮点型==。基本类型又称算术类型。
复合类型包括==数组==、==字符串==、==指针==和==结构==。（复合类型是使用其他类型创建的数据类型）

程序储存信息必须记录3个基本属性：

- 信息将储存在哪里
- 要储存什么值
- 储存何种信息 


>机员及内存的基本单元是位（bit）。
>字节通常指的是8位的内存单元，但是取决于具体实现有可能也是16位等。
>八位组（octet）表示8位字节。


sizeof运算符返回类型或变量的长度，单位为字节。

头文件`climits`（老式实现位`limits.h`）中包含了关于整形限制的信息（定义了各种限制的符号名称）

初始化：初始化将赋值与声明合并在一起。
如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该百年来个的值将是他被创建之前，相应内存单元保存的值。
初始化方式：
- 声明语句后面跟赋值语句
- 数据类型 变量名 = 表达式;
- C++使用不同的方式来初始化不同的类型。
- C++11初始化方式：用{}，大括号初始化方式可以用于任何类型，是通用的初始化语法。
- 而且在C++11中的初始化方式{}可以使用=，也可以不使用。
- 大括号内不含东西的话，变量将被初始化为零。



## 整形
整形关键字：`short`、`int`、`long`、`long long`、`char`、`bool`、`wchat_t`
|整型类型|整形关键字|长度|
|:-:|:-:|:-:|
|短整型|short|至少16位|
|整形|int|至少16位|
|长整形|long|至少32位|
|长长整形|long long|至少64位|
|字符型|char|8位|
|宽字符型|wchar_t|16位|
|布尔类型|bool||




整形可以分为符号类型和无符号类型。
仅当数值不会为负时才应使用无符号类型。
 优点：可以增大变量能够储存的最大值。
 声明，用关键词`unsiged`来修饰声明。unsigned本事就是unsigned int的缩写。

`short`、`int`、`long`和`long long`这四种类型都是符号类型。

`sizeof`运算符返回类型或变量长度，单位为字节。
头文件climit中包含了关于整形限制的信息。，定义了个中限制的符号名称。



### 头文件limits
头文件limits中定义了符号常量来表示类型的限制
 ## 浮点数
浮点数能够表示带小数部分的数。
|   类型   |   关键字    |    有效位     | 
|:--------:|:-----------:|:-------------:|
|  单精度  |    float    |     32位      |
|  双精度  |   double    |     48位      |
| 长双精度 | long double | 80、96或128位 |

有效位是指数字中有意义的位。有效位数不依赖于小数点的位置。
关于有效位数的限制可以从头文件`cfloat`或 `float.h`

需要注意：float只能表示到小数点后6位。

#### 浮点数的书写
1. 标准小数点表示法：
   `2.34`
2. E表示法:适合表示非常大和非常小的数。e大小写均可。
   格式：`dddE+n`
   `2.3e+8`
   `2.6E-2`
   `-5.3e5`
   

**浮点数优点**：
1. 可以表示整数之间的值
2. 表示范围大

**浮点数缺点**
  浮点数运算的速度通常比整数运算慢，且精度将降低。
# 1
## **sdf**
## sdf
***asdf***

[【公开课】第02讲：RAII与智能指针_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1LY411H7Gg/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8e43b8da5e07eef6f57edcd950d3b1d3)



## 数组（array）

作用：能够储存多个同类型的值。

### 数组声明

声明格式：

` typeName  arrayName[arraySize]`

- typeName指出了储存在数组中的每个元素的类型
- arrayName 数组名
- 表达式arraySize指定元素数目。必须是**整型常数**、**const值**或**常量表达式**。

arraySize在编译时都是已知的，即不能是变量。

例：

~~~ cpp
double arrayDou[5];
~~~

### 数组使用

**数组的使用**：可以使用**下标**单独访问数组中的元素。下标从0开始编号，最后一个元素的索引比数组元素少1。

**注意：**编译器不会检查使用的下标是否有效。也就是说下标所表示的元素有可能不在数组中。

使用带索引的方括号表示法来指定数组元素。比如：array[0]、array[1]、、、

对数组使用sizeof运算符：

- 对数组名使用，将得到整个数组的长度。
- 对数组元素使用，将得到元素的长度。
- 返回的长度都是以字节为单位。

### 数组初始化

只有定义数组时才能初始化，不能将一个数组数组赋给另一个数组。

1. 使用列表`{}`初始化。
   - 初始化数组时，可省略等号（=）。
   - 可不在打括号内包含任何东西，这将把所有元素都设置为零。
   - 列表初始化禁止窄缩转换。
   - 如果初始化时方括号（[]）内为空，C++将计算元素个数作为数组长度。
2. 使用下标分别给数组中的元素赋值。

初始化时，提供的值可以少于数组的元素数目，即对数组一部分进行初始化，此时编译器将把其他元素设置为0。

不初始化的危害：其元素值将是被分配的内存单元中的值，这将是不确定的。

## 字符串

C++内有两种字符串：C风格字符串和string类

要将字符串储存在数组中，有两种方式：

- 将数组初始化为字符串常量
- 将键盘或文件输入读入到数组中。

### C风格字符串

C风格字符串起源于C语言，并在C++中得到沿用。

C风格字符串本质上是以空字符（`\0`）结尾的一维char类型数组。因此，C风格字符串的长度总是比它所储存的字符多上做少一位空间。

声明C风格字符串：

~~~c
char s1[8] = {'b','e','a', ',','\0'};
char s2[8] = {"HE"};
char s3[] = "HE";//会自动在结尾添加'\0'
char s4[8] = "HE";//会自动在结尾添加'\0'，后续的元素皆设置为'\0'
~~~

### C语言库函数

头文件`cstring`  老式：`string.h`

| 序号 | 函数 & 目的                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如:  `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

需要注意的是，函数名代表着数组的地址。

注意：不能用关系运算符比较C风格字符串。

### string类

要包含头文件`string`，`string`类位于名称空间`std`中

string完全兼容C风格字符串的所有操作，并有所扩充。并且，程序能自动处理string的大小。

string类的设计能够将string对象作为一个实体，也可以作为一个聚合对象。

string对象不适用空字符来标记字符串末尾。

#### string操作

1. 赋值：使用等号（=）可以将一个string对象赋给另一个string对象。
   ~~~ cpp
   string str1;
   string str2 = "HE";
   str1 = str2;
   ~~~

2. 拼接：使用加号（+）可以将string对象拼接起来。
   ~~~ cpp
   string str3;
   str3 = str1 +str2;
   ~~~

3.  附加：使用（+=）将字符串附加到string对象的末尾。
   ~~~ cpp
   str1+=str2;
   ~~~

4. 比较：重载运算符`!=`，至少有一个操作数为string对象，另一个操作数可以是string 对象，也可以是C风格字符串。
   ~~~ cpp
   str1!=str2
   ~~~

   

**注意：**操作符对象可以是C风格字符串和string对象或两个string对象\

## 结构

一个结构可以储存多种类型的数据。

结构声明定义了结构的数据属性，并定义了一种新类型。

创建结构两步：

1. 定义结构描述。描述并标记了能够储存在结构中的各种数据类型
2. 按描述创建结构变量（结构数据对象）

### 定义结构

~~~ cpp
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
~~~

其中，object_name可以省略。object_name代表着可以在定义结构时便可以创建结构变量。用这种方式创建的还能量也可以同时被初始化。

声明结构变量：

~~~ cpp
struct type_name object_names;
type_name object_names;
~~~

在声明变量时关键字struct可以省略。

**注意：**与变量不同，C++倡导使用外部结构声明。

**注意：**还可以声明没有名称的结构类型（省略名称），同时定义一个结构类型和一个这种类型的变量。

### 使用结构

我们使用结构类型，最常使用的便是结构中的成员。

1. 使用**成员运算符（ .  ）**来访问结构成员。类的访问成员函数便源于此。

2. 结构初始化使用列表初始化`{}`。列表中的数据的类型顺序要能与定义结构时成员类型的顺序一致。其余则和普通使用列表初始化无疑。

3. 结构可以作为函数的参数，也可以作为它的返回值。

4. 成员赋值：可以使用赋值运算符（=）将一个结构赋给另一个结构。

### 结构数组

可以创建元素为结构的数组。方法与创建普通数组无异。

初始化数组：两重`{}`。初始化的用逗号分隔的值列表中的每个值本身又是一个被括在花括号中、用逗号的值列表。

## 共用体

共用体能够储存不同的数据结构，但只能同时储存其中一种结构。

声明共用体和创建共用体变量与结构无疑，使用也并无差别。

共用体的长度为其最大成员的长度。

共用体用途：当数据项使用两种或更多种数据格式（但不会同时使用时），可节省空间。因此常用于操作系统数据结构或硬件数据结构。

## 枚举

枚举（enum）可以创建符号常量，也可以定义新类型。使用枚举的句法与结构类似。

### 枚举的使用

可以将整数值赋给枚举量，第一个枚举量对应0，以此类推。需要使用强制类型转换，前提是int值是有效的。

在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。

不能将非enum值赋给enum变量。

枚举只能使用赋值运算符。（因为只定义了赋值运算符）

枚举是整形，可被提升为int类型，但int类型不能自动转换为枚举类型。因此，可在算术表达式中同时使用枚举和常规整数。

### 设置枚举值

1. 枚举值默认与整数一一对应，但可以通过赋值运算符来显式地设置枚举量地值。

2. 指定的值必须是整数，而却也可以值定义其中的一部分枚举量的值。这种情况下，后面没被初始化枚举量的值比前面的枚举量大1.

3. 可以创建多个值相同的枚举量。
4. 可以将long long 类型的整数值赋给枚举量。

## 指针

指针是一个变量储存的是值地地址，而不是值本身。对一个不同变量运用地址运算符（&）便可得到它地地址。

对指针使用间接值（解除引用）运算符（`*`）便可以得到改地址处储存的值。

cout显示地址通常使用十六进制。



**指针与常规变量区别：**

- 对于常规变量。值是指定的量，而地址是派生量。
- 对于指针。地址是指定的量，值是派生量。

### 声明和初始化指针。

指针声明必须指定指针指向的数据地类型。

~~~ cpp
typeName * pName;
~~~

`*`左右两侧空格：

- 是可选的
- 风格根据语言变。
- `typeName *pName`强调*pName是typeName类型地值
- `typeName* pName`强调typeName*是一个新类型，指向typeName类型的指针。
- 两侧空格对于编译器没有差别。

在声明多个指针时，每一个指针都需使用一个*。

在C++中，`typeName*`是一种复合类型，是指向`typeName*`的指针。

因此需要注意：指针变量不仅是指针，而且是指向特定类型的指针。说明指针是基于其他类型的数据类型。

可以在声明指针时初始化指针。

注意，被初始化的是指针，而不是它指向的值。

注意：一定要在对指针应用解除引用运算符之前，将指针初始化为一个确定的、适当的地址

### 使用new关键字来分配内存。

指针可以在运行阶段分配为命名的内存以存储值。分配之后，只能通过指针来访问内存。

C++也可以使用C语言的malloc()来分配内存。在C++中，更普遍的是使用new关键字。

为一个数据对象获得并指定分配内存的通用格式：

~~~ cpp
typeName * pointer_name = new typeName;
~~~

需要在两个地方指定数据类型：用来指定需要什么样的内存和用来生命合适的指针。

使用new关键字分配的内存块是从堆或自由储存区的内存去于分配内存。

### 使用delete关键字释放内存

delete运算符，它使得使用完内存后，能够将其归还给内存池。归还或释放的内存可供程序的其他部分使用。

通用格式：

~~~ cpp
delete pointer_name;
~~~

注意：delete 后跟的指针名，只是由new关键字分配内存的指针。不能使用delete来释放声明变量（即不是new分配的）所获得的内存。

注意：delete释放内存，但不会删除指针。释放内存后的指针仍可以被重新赋予内存。

注意：new 和delete一定要成对使用。即new为指针分配内存后，一定要有delete为其释放内存，否则会放生内存泄漏。

注意：对空指针使用delete是安全的。

注意：不能连续两次释放同一个指针。



所以，由于delete的特性，我们最好不要让多个指针同时指向同一个内存块。

### 使用new来创建动态数组

**静态联编：**在编译时给数组分配内存，意味着数组实在编译时被加入到程序中的。

**动态联编：**可以在程序运行时选择数组的长度，意味着数组是在程序运行时创建的。（动态数组）

创建动态数组格式：

~~~ cpp 
typeName * pointer_name = new typeName [num_elements];
~~~

使用new关键字创建数组之后，若要释放内存。我们要用另一种格式的delete来释放。

~~~ cpp
delete [] pointer_name;
~~~

方括号含义：告诉程序，应释放整个数组，而不仅仅是指针指向的元素。

new []和delete[]时成对的。

### 指针和数组

指针和数组基本等价的原因在于指针算数和C++内部处理数组的方式

**指针算数**：

1. 将指针变量加1后，增加的量等于它指向的类型的字节数。
2. 可以将一个指针减去另一个指针。获得两个指针的差。
   执行减法运算时，将得到一个**整数**，仅当两个指针指向同一个数组时才有意义（也可以指向超出结尾的一个位置），得到两个元素之间的间隔。用在数组时，是求数组元素数目的简便方法。

C++将数组名解释为地址。

**数组表示式的本质**

使用数组表示法时，C++将执行下面的转换：

~~~ cpp
arrayname[i] becomes *(arrayname +i)
~~~

使用的是指针时，也将执行同样的转换：

~~~ cpp
pointername[i] becomes *(pointername + i)
~~~

**指针和数组的区别**

1. 可以修改指针的值，而数组名是常量。
2. 对数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的使一个数组。（在运用sizeof运算符的时候，C++不会将数组名解释为地址。）

**数组名的两大作用：**

1. 数组名被解释为数组第一个元素的地址。同样，数组名也是整个数组的地址。
2. 数组名代表了整个数组。（例：对数组运用sizeof运算符）将地址运算符&用于数组名时，将返回整个数组的地址。

**数组表示法和指针表示法**

使用方括号数组表示法等同于对指针解除引用。

所以，在很多情况下 ，可以以同样的方式使用指针名和数组名。

### 指针和字符串

在C++中，用引号括起的字符串也是第一个元素的地址。

在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符串的地址。

C++将C风格字符串视为地址。

实例：

[[C++代码存档#程序清单 4 20 ptrstr cpp]]

**注意**，字符串字面值是常量，在用指针储存字符串字面值时要在声明中使用const关键字。如此，编译器将禁止指针指向地位置中的内容，同时也使得指针本身免受影响。

**不同编译器对于字符串字面值的处理：**

- 有些编译器将字符串字面值是为制只读常量，如果试图修改他们，将导致运行阶段错误。
- 有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值。但存在下述问题。

**C++不能保证字符串字面值被唯一地储存**，如果在程序中多次使用了一个字符串字面值，则编译器可能会储存字符串的多个副本，也可能只储存一个副本。

所以，不能使用字符串常量或为被初始化的指针来接受输入，可以使用string对象。

在将字符出读入程序时，应使用已分配的内存地址。该地址可能是数组名，也可以是使用new初始化的指针。

**cout显示指针的策略：**

- 如果给cout提供一个指针，他将打印地址。但如果指针的类型为char*，则cout将显示指向的字符串。
- 如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型。

**获得字符串的副本的方法**

1. 需要分配内存来储存该字符串
   方法：声明一个数组，或使用new（更加自由）
2. 将原数组中的字符串复制到新分配的内存当中。
   使用库函数strcpy：` strcpy(ps,animal);`。
   ps:目标地址，animal：要复制的字符串

**注意**：需要注意要复制的字符串的长度。如果长度比目标数组大，函数将会把剩余的部分复制到数组后面的内存字节中，这可能会覆盖程序正在使用的内存。

应对方法：库函数`strncpy()`，该函数接受第三个参数：要复制的字符串的最大值。

**注意：**这个最大数值要少于目标数组的长度，比如说目标数组长度是20，则这个参数最大是19。因为用数组储存字符串时，要保留一位给`\0`，以标记字符串的结尾。 这个`\0`是函数自动添加的。

**注意：**应使用`strcpy()`或`strncpy()`将字符串赋给数组，而不是赋值运算符。

### 使用new创建动态结构

动态联编优于静态联编，结构亦然。

创建和使用结构步骤：

1. 创建结构
2. 访问成员。

**访问动态结构成员：**

创建动态数组时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只有地址。

这种情况下因该使用箭头成员运算符（`->`）。

另一种方法是对只想结构的指针使用接触引用运算符再使用成员运算符。

例：

~~~C+
(*struct_pointername).member
(*ps).price
~~~

在这种情况下，根据运算符优先规则应该使用括号。

**不同情况下在结构上使用的运算符：**

1. 结构标识符是**结构名**，就使用句点运算符（`.`）。
2. 结构标识符是**指向结构的指针**，则使用箭头运算符（`->`）。



### 指针和const

**将const用于指针有两种情况：**

1. 将指针指向一个常量对象。作用是防止通过该指针来修改指针所指向的值。
2. 将指针本身声明为常量。作用是防止改变指针指向的位置。

**将const用于指针后的指针赋值：**

1. 可以将const变量的地址赋给指向const的指针。
2. 不可以将const的地址赋给常规指针（可以通过强制类型转换来强制赋值。）。
3. 仅当只有一层间接关系（指针指向的都是常规变量、常量）时，才能将非const指针赋给const指针
4. 如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向cosnt的指针，但只能将非const数据的地址赋给非const指针。
5. 不能将常量数组的地址赋给非常量指针。即，不能将数组名作为参数传递给使用非常亮形参的函数。

**将指针参数声明为指向常理数据的指针有两条理由：**

* 这样可以避免无意间修改数据而导致的编程错误
* 使用const是的函数能够处理const和非const实参，否则只能接受非const数据。


### 空指针
在 C98 中，字面值有两个含义：
- 表示数字值 `0`
- 表示空指针

表示空指针：
- `0`
- `(void*)0`
- `NULL`
- C++11：关键字`nullptr`


## 变量

变量声明格式：
`typeName valueName;`
声明中所使用的类型描述了信息的类型和变量名（使用符号来表示其值）

### 变量名命名方案

- 在名称中只能使用


用以区分数据类型的变量名的前缀和后缀

但在命名的风格中，一致性和精度是最重要的。

### 变量初始化

使用`{}`的初始化方式被称为列表初始化。常用于给复杂的数据类型提供值列表。

C++11将使用大括号的列表初始化作为一种通常的初始化方式。

### auto声明方式

作用：让编译器能能够根据初始值的类型判断变量的类型。

处理复杂类型时，auto将显出优势。

~~~ cpp
std::vector<double> scores;
auto pv = scores.begin();
~~~



**注意**：auto以前和现在的含义有所不同。



## 常量
创建常量的方法：
1. `const type name = value;`
2. `#defiane`

关键字`const`叫限定符。

需要注意，在使用const创建变量时，要注意对const初始化。
在创建变量时，推荐使用`const`，而不是`#define`。一是`const`能够指定数据类型，二是可以使用C++的作用域规则将定义限制在特定的函数或文件中，三是可以将`const`用于更复杂的类型。
### 常量命名方法
1. 通常会将常量名称的首字母大写。
2. 整个名称大写，在使用`#define`创建常量时常常使用。
3. 在名称前添加 k 字母。

### 整形字面值
整形字面值（常量）是显性书写的常量。
C++以3种方式书写常量，是根据进制的不同而划分的：基数为10、8、16.
C++表示法：
C++使用前一两位来标识数字常量的基数。
- 第一位为1~9，则为十进制
- 第一位为0，第二位为1~7则为8进制
- 前两位为0x或0X则为十六进制。
默认情况下cout以十进制格式显示整数，除非特别设定。
而数据是以二进制的方式储存在计算中。

### 字符串常量

#### 字符串常量（字符串字面值）与字符常量区别：（以`'H'`和` "H"`为例）

两者不能互换。字符常量（如` 'H'`）是字符串编码的简写形式。而`"H"`是由字符H和\0组合在一起的字符串。

而且，`"H"`实际上表示的是字符串所在的内存地址。

#### 拼接字符串常量

拼接字符串字面值：任何两个由==**空白（空格、制表符、换行符）**==分隔的字符串常量都将自动拼接为一个。

在拼接时，不会在被连接的字符串之间添加空格。这时，第一个字符串中的`\0`字符将被第二个字符串中的第一个字符取代。

拼接字符串可用于字符串变量初始化时。

~~~Cpp
char s1[] = "siud" "sdf\n";
cout << s1;
cout << "sgd" "sdf\n";
cout << "sgd"
	<<"sdf\n";
~~~





### 确定常量的类型

 整形常量通常情况下会储存为int类型，除非数值太大，或有后缀。
 后缀是放在数字常量后面的字母，用于表示类型。
 - l、L表示long常量
 - u、U表示unsigned int常量
 - ul、uL表示unsigned long常量。（顺序不限）
 - ll、LL表示long long 常量
 - ull 、Ull、uLL、ULL表示unsigned long long

 浮点常量通常情况下会储存为double。
 - f、F表示float
 - l、L表示long double

## 类型转换
C++会自动进行类型转换
- 将一种算术类型的值赋给另一种算数类型的变量时，C++对值进行转换。
- 表达式中包含不同的类型时，C++对值进行转换。
- 将参数传递给函数时，C++将对值进行转换。

### 1.初始化和赋值时进行的转换

在将一种类型的值赋给另一种类型的变量时，值将被转换成被接受变量的类型。

需要注意，将一个取值范围小的值赋给另一个取值范围大的类型不会有什么问题，比如` int`类型赋给` long`。

但将取值范围大的值赋给另一个取值范围大的类型会出现某些问题：

**潜在的数值转换问题：**

| 转换 | 潜在的问题 |
| :----: | :----------: |
| 将较大的浮点类型转换为较小的浮点类型，如double 转换成float | 精度（有效数位）降低，值可能超出目标类型的取值范围，结果将不确定。 |
| 将浮点类型转换为整形 | 小数部分丢失，值可能超出目标类型的取值范围，结果将不确定。 |
| 将较大的整形转换为较小的整形，如将long转换为short | 值可能超出目标类型的取值范围，通常只复制右边的字节。 |

任何数字值或指针值都可以被隐式转换为bool值。

需要注意：对于bool类型，0为false，非零值为true。

将布尔值赋给int类型时，false被转换为0，true被转换为1。

### 2. 以{}方式初始化时进行的转换（C++11）

在使用`{}`初始化时时，类型转换比较严格。

不允许**窄缩**，不允许将浮点型转换为整形。

当编译器知道目标变量能够正确地储存赋给它的值，就可以将不同的整形之间转换或将整形转换为浮点型。
例：

``` cpp
int x = 66;
const x1 = 66;

char c1 = {66}; //能正确赋值
char c2 = {x};//不能,因为x是一个变量，其值可能会很大
char c2 = {x1}; //能
```

### 3.表达式中的转换

表达式中包含不同的算术类型时，C++将执行自动转换：

1. 一些类型出现时便会自动转换
2. 有些类型在与其他类型同时出现在表达式中时将被转换



自动转换：**整型提升：**

bool、char、unsigned char、signed char和short将被转换为 int。（ture 被转换为1、false被转换为0）.

` short`的长度不同，unsigned  short在整形提高时转换成的类型不同：

- short比int短，则` unsigned  short`会被转换成int
- short与int长度相同，` unsigned  short`则会被转换成`unsigned int`，确保不会丢失数据。

同理，wchar_t会被提升为下列类型中第一个宽度足够储存wchar_t取值范围的类型：int、unsigned int、long或unsigned long。



算数运算时：当运算涉及两种类型时，较小的类型将被转换为较大的类型。编译器通过校验表来确定在算数表达式中执行的转换。

~~~ cpp
//校验表
1. 如果有一个操作数的类型是 long double，则将另一个操作数转换为long double。
2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。
3. 否则，如果有一个操作数的类型是 float，则将另一个操作数转换为float。
4. 否则，说明操作数都是整型，因此执行<mark><strong>整型提升。</strong></mark>
5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。
6. 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。
7. 否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
8. 否则，将两个操作数都转换为有符号类型的无符号版本。
~~~

总的来说，就是操作数表示宽度宽的优先。

整数级别：

~~~ cpp
    有符号和无符号整型：
    <code>long long > long > int short > signed  char</code>
    <code>char 、 signed char 、signed char</code>级别相同
    <code>bool</code>类型最低
    <code>wchar_t 、char16_t 、char32_t</code>与其底层类型相同
    </pre>
~~~ 

### 4. 传递参数时的的转换

传递参数时通常由C++函数原型控制。这个**控制**也可取消，但不推荐。

传递参数时，char和short类型（有符号和无符号）会被整形提升。

再将参数传递给取消**控制**的函数时，将float提升为double。

### 5.强制类型转换

强制类型转换可以显性地进行类型转换。

格式：

```c++
(typename) value  //来自C语言
value (typename)  //来自C++，格式类似于函数调用
```

**注意**：强制类型转换不会修改被转换的变量本身，而是创建一个新的、被指定类型的值，可以在表达式中使用这个值。

强制类型转换运算符：

~~~ cpp
static_cast<typeName> (value)
~~~

转换运算符比传统的强制类型转换更为严格。

[[C++代码存档#程序清单 3 4 typecast cpp]]

## 类型别名

建立类型别名：

1. 使用预处理器
   ~~~ cpp
   #define BYTE char //用char替换所有的BYTE从而使BYTE成为char的别名
   ~~~

2. 使用C++（和C）关键字`typedef`来创建别名
   ~~~ cpp
   //通用格式：
   typedef typeName aliasName;
   //例：
   typedef char byte
   ~~~

可以使用类型别名创建指针的别名

typedef不会创建新类型，而只是为已有的类型创建一个新名称。

## 左值、右值

C++ 中有两种类型的表达式：

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```
int g = 20;
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```
10 = 20;
```
***
# 循环

在设计循环时要注意以下指导原则：

- 指定循环终止的条件
- 在首次测试之前初始化条件
- 在条件被再次测试之前更新条件。

## for循环

for循环的组成部分要完成下面的步骤

1. 设置初始值
2. 执行测试，检测循环是否应当继续进行。
3. 执行循环操作
4. 更新用于测试的值。

for循环格式：

~~~ cpp 
for(initialization;test-expression;update-expression)
    body
~~~

注意：C++语法将整个for看成一条语句。循环只执行一次初始化。

注意：for是入口条件循环，每次循环之前都将计算测试表达式的值。

注意：for语句是C++关键字，因此编译器不会将for是为一个函数。
    C++常用的方式是再for和括号之间加上一个空格，而省略函数名与括号之间的空格。

## while循环

while也是入口条件循环。



检测数组中特定的字符是不是空字符：

~~~ cpp
while (name[i] != '\0')
//或：
while (name[i])
~~~



**不会将某些数值排除在外的、终止循环的方式：**将`cin>>`用作测试条件消除了这种限制，因为他接受任何有效的数字输入（需要使用循环来输入数字时，可以考虑这种方式）。非数字输入将设置了一个错误条件，禁止进一步读取输入。如果程序在输入循环后还需要进行输入，则必须使用`cin.clear()`重置输入，然后还可能需要通过读取不合法的输入来丢弃他们。

~~~ cpp
while (!cin)
{
    statements
}
~~~



### 延时循环

头文件`ctime`提供了解决方案：

定义了符号常量`CLOCKS_PER_SEC`:该常量等于每秒钟包含的系统时间单位数。

系统时间除以这个值，可以得到秒数，获或将描述乘以`CLOCKS_PER_SEC`，可以得到以系统时间单位为单位的时间。

函数clock()返回程序开始后所用的系统时间。但是返回时间不一定是秒，返回类型在不同的系统上可能不一样。

ctime将clock_t作为clock返回类型的别名。

~~~ cpp
#include<iostream>
#include<ctime> //describes clock() function, clock_t type
int main()
{
	using namespace std;
	cout << "Enter the delay time, in seconds: ";
	float secs;
	cin >> secs;
	clock_t delay = secs * CLOCKS_PER_SEC;
	cout << "starting\a\n";
	clock_t start = clock();
	while (clock() - start < delay)
		; 
	cout << "done \a\n";
	return 0;
}
~~~



## do-while循环

是出口循环。

~~~ cpp
do
    body
while (test-expression)
~~~

## 基于范围的for循环


***
# 运算符

## 算术运算符
5中基本的算术运算：加减乘除和求模。
运算符及操作数构成了表达式。
常量和变量都可用用于操作数
求模运算符要求两个操作数必须是整数。

## 赋值运算符

`=`

### 结合赋值运算符

| +=   | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A    |
| ---- | ------------------------------------------------------------ | -------------------------- |
| -=   | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A    |
| *=   | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A    |
| /=   | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A    |
| %=   | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A    |
| <<=  | 左移且赋值运算符                                             | C <<= 2 等同于  C = C << 2 |
| >>=  | 右移且赋值运算符                                             | C >>= 2 等同于  C = C >> 2 |
| &=   | 按位与且赋值运算符                                           | C &= 2 等同于  C = C & 2   |
| ^=   | 按位异或且赋值运算符                                         | C ^= 2 等同于  C = C ^ 2   |
| \|=  | 按位或且赋值运算符                                           | C \|= 2 等同于  C = C \| 2 |

## 自增自减运算符

自增自减运算符分为前缀和后缀。

对于内置类型，采用那种格式不会有差别；但对于用户定义的类型，如果用户定义的递增和递减运算符，则**前缀格式的效率更高**。

因为后缀运算符首先要复制一个副本将其加1，然后将复制的副本返回。而前缀是将值直接加1，然后返回结果。

### 在指针中运用递增、递减运算符

指针递增和递减遵循算数规则。

运用到指针上，会增加，或减少其指向的数据类型占用的字节数。

可以将接触引用运算符和递增、递减运算符结合起来使用。

首先，将什么接触引用，讲什么递增，这取决于运算符的位置和优先级。

前缀递增、前缀递减和接触引用运算符的优先级相同，以从**右向左**的方式进行结合。

~~~ cpp
*++pt//先将++应用与pt，然后将*应用于被递增后的pt
++*pt//先取得pt指向的值，然后将这个值加1
~~~

后缀递增、后缀递减优先级相同，但比前缀运算符的优先级高，这来给你个运算符从**左向右**的方式进行结合。

~~~ cpp
*pt++
//先将++运用于pt，随后是*。但++是后缀，意味着，在对pt接触引用之后才执行递增操作。
~~~

## 其他运算符

| 运算符                | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| sizeof                | [sizeof 运算符](https://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
| Condition ? X : Y     | [条件运算符](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
| ,                     | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
| .（点）和  ->（箭头） | [成员运算符](https://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |
| Cast                  | [强制转换运算符](https://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
| &                     | [指针运算符 &](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
| *                     | [指针运算符 *](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |

## 表达式

任何值或任何有效的值和运算符的组合都是表达式。再C++中每个表达式都有值。

关系表达式将被判定为bool值true或false

<<运算符的有限级比表达式中使用的运算符高，所以要使用括号。

~~~ cpp
cout<<(x>2);
~~~

**表达式的副作用：**副作用指的是计算表达式时对某些东西（如储存在变量中的值）进行了修改

**顺序点**是程序执行过程中的一个点，对于C++而言每个分号都是一个顺序点。在C++11文档中，不再使用了，旨在更清晰的描述多线程编程。

**完整表达式**不是另一个更大表达式的子表达式。

***

# 函数

要使用函数，要有

- 提供函数定义
- 提供函数原型
- 调用函数

C++提供的函数新特性：内联函数、按引用传递变量、默认的参数量、函数重载（多态）以及函数模板

## 定义函数

两类函数：有返回值和没返回值（void函数）。

void函数通用格式：

~~~ cpp 
void functionNamae(parameterList)
{
    statement(s)
    return;
}
~~~

其中，parameterList制定了传递给函数的参数类型和数量。可选的返回语句标记了函数的结尾。否则，函数将在右花括号出结束。

通常，可以用void函数来执行某种操作。

有返回值的函数将生成一个值，并将它返回给调用函数。这种函数的类型被声明为返回值的类型。

~~~ cpp
typeName functionName(parameterList)
{
    statements
    return values;
}
~~~

有返回值的函数必须要使用返回值语句，以便将值返回给调用函数。值可以是任意形式，但值的类型必须是typeName，或可以被转换为typeName类型。

C++对于返回值的类型有一定的限制：不能是数组，但可以是除此之外的任何类型。（但可以把数组作为结构或对象的组成成分来返回）。

函数在执行返回语句后结束。如果函数包含第一条语句，则函数在执行遇到的第一条返回语句后结束。

### 函数原型和函数调用

**函数原型的重要性：**

函数原型描述了函数到编译器的借口，他将函数返回值以及参数的类型和数量告诉编译器。

**原型的语法：**

函数原型是一条语句，因此必须以分号结束。

函数原型与函数定义中的函数头类似，其中的变量名是可选的。原型中的函数名相当于占位符。

**原型的功能：**

- 编译器正确处理函数返回值
- 编译器检查使用的参数数目是否正确
- 编译器检查使用的参数类型是否正确；如果不正确，则转换为正确的类型（如果可能的话）

仅当有意义时，原型才会导致类型转换。

在编译阶段进行的原型被称为静态类型检查。

静态类型检查可以捕获许多在运行阶段非常难以捕获的错误。

### 函数参数和按值传递

***函数参数对比***

| 名称 | 别名 | 定义                 |
| ---- | ---- | -------------------- |
| 形参 | 参量 | 用于接受传递值的变量 |
| 实参 | 参数 | 传递给函数的值       | 


因此参数传递将参数赋给参量。

在函数声明中声明的变量（包括参数）是该函数**私有**的。被称为**局部变量**（自动变量），会自动被分配和释放。

在定义函数时，也在函数头中使用由**逗号**（`,`）分隔的**参数声明列表**。在调用函数时，也是用**逗号**（`,`）将参数分隔开。

函数原型中的变量名不必与定义中的变量名相同。而且变量名可以省略，只保留变量类型即可。

***数组名和指针的在函数头中的区别***
C++ 将**数组名参数**视为数组的第一个元素的**地址**（指针）。从技术上讲，这仍是**按值**传递的，因为传递的指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。

当且仅当**声明函数的形参**时，下面两个声明是等价的：

~~~ cpp
typeName arr[];
typeName * arr;
~~~

都意味着 `arr` 是 `typeName` 类型的指针。实例在下面。

## 函数具体应用

### 函数与数组

函数是处理更复杂的类型的关键。

要使函数能处理数组，需要在形参列表中声明一个数组：

~~~ cpp
int sum_arr(int arr[],int n)
~~~

`arr` 实际上是一个指针，但在函数体内被看作数组。

必须将数组中的数据种类、数组的起始位置和数组中元素的数量提交给它。

在传递数据的地址时，并不会传递有关数组长度的相关信息，因此通常将数组长度作为独立的参数来传递。

在C++中，当且仅当用于函数头或函数原型中，`int *arr`和`int arr[]`的含义才是相同的。他们都意味着arr是一个int指针。

对于数组遍历来说，使用指针加法和使用数组下标是一样的。

**将数组作为参数的意义。：**
数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。

将数组地址作为参数可以节省赋值整个数组所需的时间和内存。但是增加了破坏数据的风险，可以用const限定符来解决这个问题。

**使用 `const` 保护数组：** 
方法： 在声明形参时使用关键字 `const`。

例：
~~~ cpp
void show_array(const double ar[] ,int n);
~~~

该声明表明，指针指向的时常量数据。但这并不意味着原始数组必须是常量，而只是意味着不能在show_array()函数中使用ar来修改这些数据。因此函数将数组视为只读数据。条件是：只有**一层间接关系**，即：只能用于指向基本类型的指针，二维数组就不能使用该技术。

**使用数组区间的函数：**

1. 将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数。（指针指出数组的位置和数组类型）
2. 指定元素区间（range），传递两个指针：一个标记数组的开头，另一个指针表示数组的尾部。
   STL 方法使用“**超尾**”概念来指定区间。对于数组而言，表示数组结尾的参数将是指向最后一个元素后面的指针。
   

### 函数与二维数组

与一维数组一样，二维数组的数组名依旧被视为其地址。



因此在函数中声明中，二维数组的形参应是一个指针。

因为二维数组本质上是指向指针的指针。

假如由如下代码：

~~~ cpp
int data[3][4] = {{1,2,3,4},{9,8,7,6},{2,4,6,8}};
int total = sum(data,3);
~~~

要怎么声明sum()函数的原型？

~~~ cpp
//1
int sum(int (*ar)[4],int size);
//2
int sum(int ar[][4],int size);
//两种格式含义相同
~~~

我们要声明一个指向由4个int著称的数组的指针。函数参数不能是数组。

虽然该函数执行了4列的数组，但是长度变量制定了行数，因此此函数坠数组的行数没有限制。

**注意：**数组的方括号与指针的解除引用运算符含义一样。

对于二维数组：

~~~ cpp
ar2[r][c] == *(*(ar2 + c) + C)//一样的
~~~

**注意：**对于二维数组，不能使用const来保护数据，因为const只能用于只想基本类型的指针。这与二维数组的本质有关。

### 函数和C风格字符串

#### 将C风格字符串作为参数的函数

如果要将C风格字符串作为参数传递给函数，则表达字符串的方式有3种：

1. char数组
2. 用引号括起的字符串常量
3. 被设置为字符串的地址的char指针。

因为上述3者的本质都是char指针（`char*`），所以函数的形参类型应为`char*`类型，当然，也可以为`char[]`类型

C风格字符串与char数组之间的一个重要区别是，字符串内有内置的结束字符（没有结束字符的char数组只是一个数组）。

这意味着可以省去作为字符串长度的形参，而由函数检查字符串（结束条件是遇到空值字符）。

其中，用来储存字符串长度的变量可以声明为`unsigned int`类型，因为字符串的长度不能为负数。

处理字符串中字符的标准形式：

~~~ cpp
while (*str)
{
    statements
    str++;
}
~~~



当指针指向字符串结尾时，``*str`的值为`\0`，从而结束循环。

#### 返回C风格字符串的函数

函数无法返回一个字符串，但可以返回字符串的地址。（效率也更高）

可以使用new关键字来动态的为字符串分配内存。

可以在函数内使用new关键字分配内存，然后在主函数内使用delete来释放内存。

但缺点是，一定要使用delete来释放内存。

### 函数和结构



结构的特殊性在于，整个结构可以被视为一个整体。

可以按值传递结构，这时，函数使用的是结构的副本。

与数组不同，结构名只是结构的名称，想要获得结构的地址还要使用&运算符。

推荐将结构的地址作为参数传递。因为如果按值传递结构，当结构比较大时，会降低系统运行速度。

但当结构比较小时，按值传递结构最合理。



## 递归

递归函数调用自己

~~~ cpp
void recurs(arguments)
{
    statements1
    if (test)
        recurs(arguments)
    statements2
}
~~~

以上是void类型的递归函数，包含一个递归调用的递归

递归方法有时被称为分而治之策略。

也可以有包含多个递归调用的递归

## 函数指针

函数也有地址。函数的地址是储存其机器语言代码的内存的开始地址

***将函数指针传递给函数的步骤：***

1. 获取函数的地址
   使用函数名即可,要将函数作为参数传递必须使用函数名。一定要区分传递的是函数还是函数的返回值

2. 声明函数指针
   声明指针时，必须指定指针指向的函数类型。声明应指定函数的返回类型以及函数的特征标（参数列表）

   ~~~ cpp
   //函数原型
   double pam(int);
   //函数指针
   double (*pf)(int);
   ~~~

   因此，只需将函数原型中的函数名替换为 `(*pf)`即可，必须要有括号

3. **使用指针来调用函数**
   `(*pf)`与函数名(`pf`)意义相同。
   **用指针调用函数形式：**

   - `(*pf)(参数列表)`   ：pf是函数指针，*pf是函数
   - `pf(参数列表) `     ：pf是函数指针，而函数名也是指针。因此两者行为类似。

   这两种调用背后的思想是不同的，但是C++都认为正确。

### 指向函数指针的指针

~~~ cpp
const double * f1(const double ar[], int n);
const double * f2(const double [] , int)
const double * f3(const double * , int)
~~~

以上三个函数原型的特征标相互等价。

上述函数的返回值类型为` const double *`

**声明：**

要声明指向上述返回类型的函数的函数指针，声明方式与正常声明函数指针一致，将`(*pa)`替换函数名即可。

同样的，也可以在声明的时候初始化。

~~~ cpp 
const double * (*pa)(const double * , int) = f1;
~~~

也可以使用自动类型判断功能：

~~~ cpp 
auto p1 = f2;
~~~

**函数指针数组：**

**注意：** 运算符 `[]` 的优先级高于*。

**声明：**包含初始化

~~~ cpp
const double * (*pa[3])(const double * , int) = {f1,f2,f3};
~~~

![image-20220504210330573](https://growlr-center-blog-image.oss-cn-beijing.aliyuncs.com/image/image-20220504210330573.png)

**注意：** 在这时就不能用 `auto` 自动声明了，因为自动类型判断只能用于单值初始化，而不能用于初始化列表。

但可以用 `auto` 声明相同类型的数组：

~~~ cpp
auto pd = pa;
~~~

`pa` 和 `pd` 都是指向函数指针的指针。

**利用指向函数指针的指针数组调用函数：**

`pa[i]` 和 `pd[i]` 都是指向函数指针的指针，可将任何一种函数调用表示法用于他们：

~~~ cpp 
const double * px = *pa[0](av,3);
const double * py = (*pb[1])(av, 3);
//二者等价 
~~~



**获得指向的 `double` 值：** 使用运算符 `*`

~~~ cpp
double x = *pa[0](av,3);
double y = *(*pd[1])(av,3);
~~~

**创建指向整个数组的指针：**

1. 关键字 `auto` ：
   ~~~ cpp 
   auto pc = &pa;
   ~~~

2. 在指向函数指针的指针数组中添加*
   ~~~ cpp
   const double *(*(*pd)[3])(const double *, int) = &pa;
   ~~~

   ![image-20220504220156103](https://growlr-center-blog-image.oss-cn-beijing.aliyuncs.com/image/image-20220504220156103.png)

**用指向函数指针数组的指针调用函数：**

1. 较简单的函数调用：`(*pd)[i](av,3)`
   因此 `*(*pd)[i](av,3)` 时返回的指针指向的 `double` 值
2. 使用指针调用函数：`(*(*pd))[i](av,3)`
   因此 `*(*(*pd))[i](av,3)` 时返回的指针指向的 `double` 值

两种调用方式等价。

**注意：** `pa` 和 `&pa` 的区别。`pa` 指的是数组第一个元素的地址，即：`&pa[0]`，因此是单个指针的地址。但 `&pa` 是整个数组的地址。虽然从数字上来说，两者的值相同，但他们的类型不同。

**两者差别：**

- 在指针算数方面。pa+1为数组的下一个元素的地址，而&pa+1为整个数组后面的地址。

- 要得到第一个元素的值，只需对pa解除一次引用，但需要对&pa解除两次引用
  ~~~ cpp
  **&pa == *pa == pa[0]
  ~~~


## 内联函数

内联函数与常规函数之间的主要区别是：C++编译器如何将他们组合到程序中。

编译器用相应的函数代码代替函数调用。

内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。



**使用内联函数：**

- 在函数声明前加上关键字`inline`
- 在函数顶以前加上关键字`inline`
- 通常的做法是省略原型，将整个定义放在本应提原型的地方。

内联函数和常规函数一样，也是按值传递的。

## 引用变量

引用变量是复合类型。

引用是已定义的变量的别名。

主要用途是用作函数的形参。

函数通过引用变量可以直接使用原始数据。这为函数处理大型结构提供了一种途径。

对于设计类来说，引用必不可少。

### 创建引用变量

使用`&`来声明引用，此时，`&`就是类型标识符的一部分。

~~~ cpp
int rats;
int & rodents = rats;//rodents 的类型为 int &
~~~

他们指向相同的值和内存单元。

可以创建指向 `rats` 的指针。

引用变量与指针的差别：引用变量必须在声明时进行初始化。

### 将引用变量用作函数参数。

引用将常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法被称为按引用传递。

如果想让函数使用传递给它的信息，而不对这些信息进行修改，同时又想引用，则应使用常量引用。

应在函数原型和函数头中使用 `const`。相比于按值传递，在数据比较大时，这样声明将会很有用。



**临时变量、引用参数和cosnt**

如果实参与引用参数==不匹配==，C++将生成临时变量。仅当参数为 `const` 引用时，C++才允许这样做。

创建临时变量的情况：

- 实参的类型正确，但不是左值
- 实参的类型不正确，但可以转换为正确的类型。

常规变量和 `cosnt` 变量都可被视为左值。

如果接受引用参数的函数的意图时修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。

解决的方法是禁止创建临时变量，现在的C++标准正是这样做的。

对于形参为 `const` 引用的 C++函数，如果实参不匹配，则其类型类似于按值传递，为确保原始数据不被修改，将使用临时变量来储存值。

**将引用参数声明为常量数据的引用的理由有三个**

- 使用 `const`引用可以避免无意中修改数据的编程错误
- 使用 `const`引用使函数能够处理 `const`和非 `const`实参，否则将只能接收非 `const`数据。
- 使用 `const`引用是函数能够正确生成并使用临时变量。

### 何时使用引用参数

***使用原因：***

- 程序员能够修改该函数中的数据对象
- 通过传递引用而不是整个数据对象，可以提高程序的运行效率。(当数据对象较大时，如结构和类对象)

***指导原则：***

1.  对于使用传递的值而不做修改的函数
	- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
	- 如果数据对象是数组，则使用指针，因为这时唯一的选择，并将指针声明为指向 `const` 的指针。
	- 如果数据对象是较大的结构，则使用 `const` 指针或 `const` 引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
	- 如果数据对象是类对象，则使用 `const` 引用。类设计的寓意常常要求使用引用

2. 对于修改调用函数中数据的函数
	- 如果数据对象是内置数据类型，则使用指针
	- 如果数据对象是数组，则只能使用指针
	- 如果数据对象是结构，则使用引用或指针
	- 如果数据对象是类对象，则使用引用

3. 以上只是指导意见，可以做出其他的选择


### 右值引用

这种引用可指向右值，使用`&&`声明：

~~~ cpp
double && rref = std::sqrt(36.00);
double j = 15.0;
double && jref = 2.0* j +18.5;
~~~

目的：让库设计人员能够提供有些操作的更有效。

因此，用`&`声明的被称为左值引用。

### 返回引用

传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将计算结果返回给调用函数。从概念上说，这个值给复制到一个临时位置，而调用程序将使用这个值。

返回引用的函数实际上使被引用的变量的别名。

返回引用的最重要的一点：应避免返回函数终止时不再存在的内存单元引用。

避免这种问题的解决方法：

- 返回一个作为参数传递给函数的引用

- 用 `new` 来分配新的内存空间。
  ~~~ cpp
  const free_throws & clone(free_throws &ft)
  {
      free_throws * pt;
      *pt = ft;
      return *pt;
  }
  ~~~

  但是不要忘了用 `delete` 释放内存。

**将 `const` 用于返回类型：** 要使用返回值，但又不允许执行给函数的复制操作，只需将返回类型声明为 `const` 引用。

## 默认参数

**默认参数** 指的是当函数调用中省略了实参时自动使用的一个值。

**设置默认值** ：通过函数原型。将值赋给原型中的参数。

**添加默认值的顺序**： 对于带参数列表的函数，必须从右到左添加默认值，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值。

**函数实参赋值给形参的顺序：** 实参值按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。

**优点：** 使用默认参数，可以减少要定义的结构函数、方法以及方法重载的数量。

**注意：** 只有原型指定了默认值。函数定义与没有默认参数时完全相同。

例：
~~~ cpp
int harpo(int n, int m = 4, int j = 5);
~~~


## 函数重载

函数重载又称函数多态，可以使用多个重名的函数。

C++使用上下文来确定要使用的重载函数版本。

**函数特征标**：函数的参数列表。函数的特征标是否相同与函数名无关。是特征标，而不是函数类型使得可以对函数进行重载。

编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征。但是区分 `const` 和非 `const` 变量（指针）。

**合适使用函数重载**
仅当函数基本上执行相同的任务，但使用**不同形式**的数据时，才应采用函数重载。

**名称修饰（名称矫正）：** C++编译器根据函数原型中指定的形参类型对每个函数名进行加密。

## 函数模板



**函数模板** 是通用的函数描述，使用**泛型**来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。

模板声明不是将被编译的代码，他们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。

**模板实例**：函数模板只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是**模板实例**。

模板并非函数定义，但是用 `int` 的模板实例是函数定义。

**通用编程：** 模板允许以**泛型**（而不是具体类型）的方式编写程序。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型。

**使用场景：** 需要对多个不同类型使用同一种算法时。

### 定义函数模板

**模板函数定义的一般形式**：
~~~ cpp
template <typename type> ret-type func-name(parameter list)
{
   // 函数的主体
}
~~~
其中，关键字 `typename` 是可以被关键字 `class` 替换的，二者在上下文中等价。关键字 `typename` 是在 C++98 中被加入的。因此应使用关键字 `typename`。
**实例**：
```cpp
template <typename T>//或 class T
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
}
```
在这里，`type` 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。
**函数模板的实例**:
[[C++代码存档#8 11]]
~~~ cpp
//功能：返回两个数中的最大值
#include <iostream>
#include <string>
 
using namespace std;
 
template <typename T>
inline T const& Max (T const& a, T const& b) //内联
{ 
    return a < b ? b:a; 
} 
int main ()
{
 
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 
 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
 
    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
 
    return 0;
}
~~~

模板也可重载。但并非所有的模板参数都必须是模板参数类型。

### 具体化

^80ffe4

**目的**：为了解决函数模板的局限性。

隐式实例化、显式实例化和显式具体化统称为具体化。他们表示的都是使用据特类型的函数定义，而不是通用描述。 ^098d72

#### 显式具体化
**显式具体化**：提供一个具体化的函数定义。

**第三代具体化标准定义形式**：（C++98）

- 对于给定的函数名，可以有非函数模板、模板函数和显式具体化模板以及他们的重载版本。
- 显式具体化的原型和定义应以 `template<>` 打头，并通过名称来指出类型
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。
	- 如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。

**具体化语句：**
~~~ cpp
template <> void Swap<jop>(job &, job &);//正常
template <> void Swap(job &, job &);     //简化
~~~
上述两种函数参数声明等价，` Swap<jop>` 中的 `<jop>` 是可选的，因为函数的参数类型表明，这是 `job` 的一个具体化。

**注意：** 在代码中包含函数模板本身并不会生成函数定义。



#### 显性实例化

**显性实例化**： 直接命令编译器创建特定的实例。

**语法**：声明所需的种类——用 `<>` 符号指示类型，并在声明前加上 `template`

~~~ cpp
template void Swap<int>(int, int);
~~~

该语句的意思是，使用 `Swap` 模板生成 `int` 类型的函数定义（实例）。

可以在程序中使用函数来创建显式实例化。

~~~ cpp
template <class T>
T Add(T a,T b)//改模板要求两个函数参数的类型相同。
{
   return a + b;
}
...//省略
int m = 6;
double x = 10.2;
cout << Add<double>(x,m) << endl;
//当两个实参类型不同时，引用参数不能用这种方法
~~~

#### 显式具体化与显式实例化

**区别：**

1. 语法不同：
   - 显式具体化使用前缀 `template<>`。
   - 显式实例化使用 `templat`，其中不包括 `<>`。
2. 含义不同：
   - 显式具体化的意思是：**不要使用模板来生成函数定义 ，而应使用专门为某个数据类型显式地定义函数定义** 。 
   - 显式实例化地意思是：**使用模板生成某个数据类型地函数定义**。
3. 声明语句：以 `int` 类型举例
	- 显式具体化 ,可以使用下面两个等价的声明之一。
	   ~~~ cpp
	   template <> void Swap<int>(int &, int &);
	   template <> void Swap(int &, int &);
	   ~~~
   - 显式实例化
	   ~~~ cpp
	  template void Swap<int>(int, int);
	   ~~~
   

**注意：** 不能再同一个文件中使用同一种类型地显式实例和显式具体化，因为这将会出错。

### 编译器使用哪个函数版本

**重载解析：** C++利用一个定义的策略，来决定使用哪一个函数定义即最匹配的函数。

**最具体：** 并不意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。

**模板函数的部分排序规则：** 用于找出最具体的模板的规则。（C98新增）

**解析过程**：
1. **创建候选函数列表。** 其中包括与被调用函数的名称相同的函数和模板函数。
2. **使用候选函数列表创建可行函数列表。** 这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括参数类型与相应的参数类型完全匹配的情况。
3. **确定是否有最佳的可行函数。** 如果有则使用它，否则该函数调用出错。
	确定最佳可行函数，从最佳到最差：
	查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。
	1. 完全提升, 但常规函数优于模板。
	2. 提升转换
	3. 标准转换
	4. 用户自定义转换，如类声明中定义的转换。

#### 完全匹配和最佳匹配
进入完全匹配时，C++允许某些：“无关紧要的转换”：

`Type` 表示任何类型。`Type(argument-list)` 意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。

| 从实参                | 到形参                     |
| --------------------- | -------------------------- |
| `Type`                | `Type &`                   |
| `Type&`               | `Type`                     |
| `Type[]`              | `* Type`                   |
| `Type(argument-list)` | `Type(*) (argeument-list)` |
| `Type`                | `const Type`               |
| `Type`                | `volatile Type`            |
| `Type *`              | `const Type`               |
| `Type *`              | `volatile Type *`          | 

如果有多个匹配的原型，则编译器将无法完成重载解析过程。
如果没有最佳的可行函数，则编译器将生成一条错误信息，该信息可能使用诸如二义性这样的词语。

#### 创建自定义选择

可以编写合适的函数调用，引导编译器做出希望的选择。

```cpp
func_name(num1,num2);
```

不做任何操作时，编译器选择非模板函数（假设有）。

```cpp
func_name<>(num1,num2);
```

这条语句中的 `<>` 指出：编译器应选择模板函数。

```cpp
func_name<int>(num1,num2);
```

这条语句中的 `<int>` 指出：要求模板函数显式实例化。其中的参数将被强制转换为 `int` 类型。

#### 多个参数的函数

所有参数的匹配情况，编译器都要考虑到。

至少有一个参数的匹配程度要比其他函数都高。

### 模板函数的发展（C++11）

#### 关键字 `decltype`

C++98 的问题：并非总能知道应在声明中使用哪种类型。例：
```cpp
template<class T1,class T2>
void ft(T1 x,T2 y)
{
	...
	?type? xpy = x + y;
	...
}
```

C++11 的解决方案：关键字 `decltype`
实例：
```cpp
int x;
decltype(x) y;
```
创建和 `x` 一样类型的 `y`

解决方案：
```cpp
//1.
decltype(x+y) xpy;
xpy = x + y;
//2.
decltype(x+y) = x + y;
```

`decltype` 机制：编译器便利一个核对表
```cpp
decltype(expression) var;
```
1. 如果 `expression` 是一个没有用括号括起来的标识符，则 `var` 的类型与该标识符的类型相同。
2. 如果 `expression` 是一个函数调用，则 `var` 的类型与函数的返回类型相同。
	在这个过程中没有（也不需要）调用函数，编译器只是查看函数的原型来获悉返回类型。
3. 如果 `expression` 是一个左值，则 `var` 为指向其类型的引用。
	且， `expression` 是用括号括起来的标识符。(括号不会改变表达式的值和左值性)
4. 上述条件都不满足，则 `var` 的类型与 `expression` 的类型相同

 **注意：** `decltype` 可以与 `typedef` 结合使用。
 
```cpp
typedef decltype(x+y) xytype;
```
	
必须在声明参数后使用 `decltype`

#### C++11 后置返回类型

 `decltype` 无法解决模板函数声明中返回类型的问题。
 
 例子：
```cpp
double h(int x,float y);
//新语法
auto h(int x , float y) -> double;
```

新语法将返回类型移动了参数声明后面。`->double` 被称为**后置返回类型**

`auto` 是一个占位符，用来表示后置返回类型提供的类型。

这种语法也可用于函数定义中。

结合 `decltype` 使用，便可给模板函数指定返回类型。例：
```cpp
template<class T1, class T2>
auto gt(T1 x,T2 y) -> decltype(x+y)
{
	...
	return x+y;
}
```

此时， `decltype`可以被使用，因为`x`和`y`在作用域内（已被定义），可以使用它们。

***

# 内存模型和名称空间

## 单独编译

**组织程序的策略**：将程序分为三部分
- 头文件：包含结构声明和使用这些结构的函数的原型。
- 源代码文件：包含与结构有关的函数的代码
- 源代码文件：包含调用与结构相关的函数的代码。

**软件包**：有两个文件组成
- 头文件：包含了用户定义类型的变量
- 文件：包含操纵用户定义类型的函数的的代码。

不能将函数定义或变量放到头文件中。

**头文件常包含的内容**：
- 函数原型
- 使用 `#define` 或 `const` 定义的符号常量。
- 结构声明（因为不创建变量）
- 类声明
- 模板声明（模板声明不是被编译的代码）
- 内联函数（被声明为const的数据和内联函数有特殊的链接属性。）

**在使用 `#include` 包含头文件时，不同的符号包含文件名会有不同的查找优先度**：
- 文件名包含在尖括号中，则C++编译器将在储存标准头文件的主机系统的文件系统中查找
- 文件名包含在双引号中，则将在标准位置查找。所以在包含自己的头文件时，应使用引号。

### 头文件管理

在同一个文件中只能将同一个头文件包含一次。

使用预处理器编译指令`#ifndef`即可避免多次包含同一个头文件。

~~~ cpp
#ifndef COORDIN_H_
#include COORDIN_H_
// place include file contents here
#endif
~~~
这种**防护方案** 并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容。
## 存储持续性、作用域和链接性

***存储持续性：***

C++使用4种不同的方案来储存数据，这些方案的区别在于数据保留在内存中的时间。
- **自动存储持续性**：在函数声明中声明的变量（包括函数参数）的储存持续性为自动的。在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，他们使用的内存被释放。
- **静态存持续储性**：在函数定义外定义的变量和使用关键字 `static` 定义的变量的储存持续性都为静态。在程序整个运行阶段都存在。
- **线程存储持续性（C++11）**：如果使用关键字 `thread_local` 声明的，则其生命周期与所属的线程一样长。
- **动态存储续储性**：用 `new` 运算符分配的内存将一直存在，直到使用 `delete` 运算符将其释放或程序结束为止。这种内存的持续性为动态，有时被称为自由储存或堆。

***作用域：***

**不同的C++存储方式是通过储存持续性、作用域和链接性来描述的。**

**作用域** 描述了名称在文件（翻译单元）的多大范围内可见。

| 变量作用域         | 范围                         |
| ------------------ | ---------------------------- |
| 局部               | 定义它的代码块中             |
| 全局（文件作用域） | 在定义位置到文件结尾之间     |
| 函数原型作用域   | 只在包含参数列表的括号内可用 | 



| 类型     | 作用域                               |
| -------- | ------------------------------------ |
| 自动变量 | 局部                                 |
| 静态变量 | 取决于如何被定义                     |
| 类中成员 | 整个类                               |
| C++函数  | 整个类或整个名称空间，但不能是局部的 |
| 名称空间 | 整个名称空间                         | 

- 作用域为**局部**的变量只在定义它的代码块中可用。
- 作用域为**全局（也叫文件作用域）** 的变量在定义位置到文件结尾之间都可用。
- 自动变量的作用域为**局部**
- 静态变量的作用域取决于如何被定义。
- 函数原型作用域中使用的名称只在包含参数列表的括号内可用。
- 在类中声明的成员的作用域为整个类。
- 在名称空间中声明的变量的作用域为整个名称空间。（全局作用域是名称空间作用于的特例）
- 函数的作用域可以是整个类或整个名称空间，但不能是局部的。（局部的函数将无法被调用）

***链接：***

**链接性** 描述了名称如何在不同单元间共享。

| 链接性 | 共享的单元范围 |
| ------ | -------------- |
| 外部   | 文件间         |
| 内部   | 一个文件内     |
| 没有（不能共享）   | 自动变量       | 

- 链接性为**外部** 的名称可在文件间共享
- 链接性为**内部** 的名称只能由一个文件中的函数共享。
- 自动变量的名称没有链接性，因为他们不能共享

### 自动存储持续性

在默认情况下，在函数中声明的函数参数和变量的存储性持续性为自动，作用域为局部，没有链接性。

如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。

在代码块内外各有一个同名的变量，当程序执行内部代码块的语句时，将这个名称的变量解释为局部代码块变量，即：新的定义**隐藏**了以前的定义，新定义可见，就定义暂时不可见。当程序离开该代码块时，原来的定义又重新可见。

**自动变量管理：** 程序采用栈管理临时变量。栈的默认长度取决于实现。

还有寄存器变量


### 静态存持续储性

C++为静态存储持续性变量提供了三种链接性：
- 外部链接性
- 内部链接性
- 无链接性

这三种链接性在程序运行期间都存在。

静态变量的数目在程序运行期间是不变的。因此程序将分配固定的内存块来储存所有的静态变量，这些变量在程序运行期间一直存在。

**零初始化：** 如果没有显式地初始化静态变量，编译器将把它的所有位设为 `0`.

**创建：**
- 外部链接性，在代码块的外面声明
- 内部链接性，在代码块的外面声明，并使用`static`限定符。
- 无链接性，在代码块内部声明，并使用 `static` 限定符。

**引入名称空间之前的存储特性：**

| 存储描述 | 持续性 | 作用域 | 链接性 | 如何声明 |
| -------- | ------ | ------ | ------ | -------- |
|自动|自动|代码块|无|在代码块中|
|寄存器|自动|代码块|无|在代码块中，使用关键字`register`|
|静态，无链接性|静态|代码块|无|在代码块中，使用关键字`static`|
|静态，外部链接性|静态|文件|外部|不在任何函数内|
|静态，内部链接性|静态|文件|内部|不再任何函数内，使用关键字`static`|

**静态变量的初始化**

静态变量的初始化方式：
1. 零初始化：
	对于标量类型，零将被强制转换为合适的类型。结构成员被零初始化，且填充为都被设置为零
2.  常量表达式初始化
3. 动态初始化

零初始化和常量表达式初始化被统称为**静态初始化**。

这意味着在编译器处理文件（翻译单元）时初始化变量。

动态初始化意味着变量将在编译后初始化。

初始化步骤：
首先所有的静态变量都被零初始化（无论是否被显式初始化）。其次，如果使用常量表达式（可使用`sizeof`运算符）初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化。如果没有足够的信息，变量将被动态初始化。
#### 静态持续性，外部链接性

链接性为外部的变量简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量也称全局变量（相对于局部的自动变量）。

**单定义规则：**变量只能有一次定义。

单定义规则并非意味着不能有多个变量的名称相同。比如，在不同的函数中可以有同名的变量（这些变量是彼此独立的，各有各的地址）。

**两种变量声明：**

1. 定义声明（简：定义），给变量分配空间
2. 引用声明（简：声明），不给变量分配空间，而是引用已有的变量。

**引用声明：** 关键字 `extern`，不进行初始化。（如果进行初始化，则是声明为定义，导致分配空间）。

**引用使用：** 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他文件中，都必须使用关键字 `extern` 声明它。

~~~ cpp
//file01.cpp
extern int cats =20;//初始化了，在此文件中被声明为定义
int dogs = 20;
int fleas;
//file02.cpp
//
extern int cats;
extern int dogs;
~~~

**在函数内部使用全局变量：**

1. `extern`
2. `::` 作用域解析运算符。放在变量名前面：`::name`

**全局变量优缺点：**
- 优点：适于保存常量数据
- 缺点：会导致程序不可靠

#### 静态持续性，内部链接性

将 `static` 限定符用于作用域为整个文件的变量时，该变量的链接性为**内部**的。

如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。并且，没有违反单定义规则。

这样隐藏的规则的好处：如果将作用域为为整个文件的变量变为静态的，就不用担心其名称与其他文件中的作用域为整个文件的变量发生冲突。

~~~ cpp
//file1
int errors = 20;
//file2
static int errors = 5;//static指出标识符errors的链接性为内部。
~~~

**在不同的作用域之间共享数据**

- 可使用外部变量在多文件程序的不同部分之间共享数据。
- 可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据



#### 静态持续性，无链接性

创建：将 `static` 限定符用于在代码块中定义的变量。

在代码块中使用 `static`，将导致局部变量的存储持续性为静态的。改变量虽然只在该代码块中可用，但它在改代码块不处于活动状态时仍然存在（在两次函数调用之间，静态局部变量的值将保持不变）。

如果初始化了局部静态变量，则程序只在启动时进行一次初始化，以后再次调用时不会再被初始化。



### 说明符和限定符

存储限定符（或c-v限定符，是C++关键字）提供了其他有关储存的信息。

- auto（在C++11中不再是说明符）
- register
- static
- extern
- thread_local（C++新增的）
- mutable

同一个声明中不能使用多个说明符，但 `thread_load` 可与 `static` 或 `extern` 结合使用。

1. c-v限定符

   - `const`
   - `volatile`表明：即使程序代码没有对内存单元进行修改，其值也可能发生变化。该关键字的作用是为了改善编译器的优化能力（不让编译器将值缓存到寄存器中）。

2. `mutable`

   - 可以用它来指出，即使结构（或类）变量为 `const`，其某个成员也可以被修改
   - 例：
		```cpp
		struct data
		{
			char name[30];
			mutable int accesses;
		};
		const data veep = {"HE",0};
		veep.accesses++;//这个操作是可行的
		```


3. `const`

   - `const`使得全局变量由外部链接性改为内部。如同使用了`static`。

   - 在头文件中声明常量后，包含头文件的其他程序文件中都会包含头文件中的常量。（这也是`const`为内部链接性的原因，如果不是将会违反单定义规则）

   - 内部链接性意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量

   - 如需使某个常量的链接性为外部的，则可以用`extern`关键字来覆盖默认的内部链接性
     ~~~ cpp
     extern const int states = 50;
     //在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。
     ~~~

   - 在函数或代码块中声明`const`时，其作用域为代码块。

     仅当程序执行改代码块中的代码时，该变量才是可用的
     不用担心其名称与其他地方定义的常量发生冲突

### 函数和链接性

   C++不允许在一个函数中定义另一个函数，因此所有的函数的存储持续性都自动的静态。

   默认情况下，函数的链接性为外部的，即可在文件间共享。

   可使用关键字`static`将函数的链接性设为内部的，使之只能在一个文件中使用。

   必须同时在原型和函数定义中使用该关键字。

   ~~~ cpp
   static int private(double);
   ...
   static int private(double)
   {
      ... 
   }
   //这意味着该函数旨在这个文件中可见。还以为者可以在其他文件中定义同名的函数
   //和变量一样，在定义静态函数䣌文件中，静态函数将覆盖外部定义
   ~~~

   单定义规则也适用于非内联函数，因此对于非内联函数，程序只能包含一个定义。但使用该函数的文件都应包含其函数原型。

   内联函数不受这项规则的限制，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。

### 语言链接性

链接程序寻找与 C++函数调用匹配的函数时，使用的方法与 C 语言不通。

如果要在 C++程序中使用 C 库中预编译的函数，应该用函数原型来指出要使用的约定。

```cpp
extern "C" void spiff(int);		//使用C语言链接性
extern void spiff(int);			//使用C++语言链接性
extern "C++" void spiff(int);	//使用C++语言链接性
```

如果未在函数原型中指定语言链接性，则默认是 C++语言链接性。

C 和 C++链接性事 C++标准指定的说明符，但实现可提供其它语言链接性说明符。

### 存储方案和动态分配

动态内存被`new`和`delete`控制，而不是由作用域和链接性规则控制。

动态内存不是 `LIFO`，而是堆（定位除外）。

==**编译器要使用三块独立的内存：**==

- 用于静态变量
- 用于自动变量
- 用于用于动态储存。

存储方案不适用于动态内存，但是用于用来跟踪动态内存的自动和静态指针变量

==**`new`运算符的说明：**==

1. **使用`new`运算符初始化（分配空间并初始化）**
   **初始化**动态分配的变量：

   - 内置的标量类型：在类型名后加上初始值（C++98）
     ~~~ cpp
     int *pi = new int (6);			//设置*pi为6
     double *pd = new double (99.99);//设置*pd为99.99
     ~~~

     （这种括号语法也适用于有合适构造函数的类）
     （C++11）：可将列表初始化用单值变量：

     ~~~ cpp
     int *pin = new int {6};			 //设置*pin为6
     double *pdo = new double {99.99};//设置*pdo为99.99
     ~~~

   - 常规结构或数组：大括号的列表初始化（C++11）
     ~~~ cpp 
     struct where {double x;double y;double z;};
     where * one = new where {2.5, 5.3 , 7.2};	//C++11
     int * ar = new int [4] {2,4,4,6,7};			//C++11
     ~~~

2. **`new` 失败时**
   **描述**：`new`可能找不到请求的内存量
   **处理**：

   - 最初的10年，返回空指针
   - 现在将引发异常`std::bad_alloc`

3. **`new`：运算符、函数和替换函数。**
   运算符`new`和`new[]`分别调用如下函数：

   ~~~ cpp
   void * operator new(std::size_t); 	//被new使用
   void * operator new[](std::size_t); //被new[]使用
   ~~~

   这些函数被称为**分配函数**，位于**全局名称空间**中。
   `delete`和`delete[]`同理：

   ~~~ cpp
   void operator delete(void *);
   void operator delete[](void *);
   ~~~

   `std::size_t`是一个`typedef`对应于合适的整形。
   使用new运算符会有一个转换过程：

   ~~~ cpp
   int * pi = new int;
   int * pa = new [40];
   ~~~

   被转换为：
   ~~~ cpp
   int * pi = new(sizeof(int));
   int * pa = new(40 * sizeof(int));
   ~~~

   可以看出，new是根据字节数分配内存的。

   当使用`new`初始化时，不仅仅调用`new`函数

   使用delete运算符也有：
   ~~~ cpp
   delete pi;
   ~~~

   被转换为
   ~~~ cpp 
   delete (pi);
   ~~~

   **注意** ：这些函数是**可替换**的，意思是可根据自己的意愿提供替换函数，并定制这些函数。

4. **定位new运算符**
   定位new运算符能够指定要使用的位置。
   **用处：**设定**内存规范**、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。与初始化结合，从而将信息放到特定的硬件地址处。
   **原理：** 返回传递给它的地址，并将其强制转换成`void *`，以便能够赋给任何指针类型（默认new）。

   **使用**：包含头文件 `new`，然后制定位置参数。其余与常规 new 相同（方括号可选）。
	**注意** ：定义运算符使用传递给它的地址，他不跟踪哪些内存单元已被使用，也不查找未使用的内存块，需要程序员手动进行内存管理。也不能用`delete`释放内存。
   **实例：**

   ~~~ cpp
   #include <new>
   struct chaff
   {
       char dross[20];
       int slag;
   };
   char buffer1[50];
   char buffer2[500];
   int main()
   {
       chaff *p1,*p2;
       int *p3,*p4;
       //常规new使用
       p1 = new chaff;
       p3 = new int[20];
       //定位new使用
       p2 = new (buffer1) chaff;
       p4 = new (buffer2) int[20];
   }
   ~~~

   该实例使用两个静态数组来为`new`运算符提供内存空间。
   同样，标准定位`new`也调用就收两个参数`new()`函数：

   ~~~ cpp
   p2 = new (buffer1) chaff;	//new(sizeof(int),buffer1)
   p4 = new (buffer2) int[20];	//new(40*sizeof(int),buffer2)
   ~~~

   定位`new`函数不可替换，但可重载，至少接受两个参数，其中第一个参数总是`std::size_t`，这指定了请求的字节数。
   这样的重载函数被称为定义 `new`，即使额外的参数没有指定位置。
	

## 名称空间

名称可以是变量、函数、结构、枚举、类以及类和结构的成员。

作用：更好的控制名称的作用域。

术语说明：

- **声明区域**：是可以在其中进行声明的区域。
- **潜在作用域**，变量的潜在作用域从声明开始，到期声明区域的结尾。所以潜在作用域比生命区域小。
  变量并非在潜在作用域的任何位置都是可见的，有可能会被隐藏。

C++关于全局变量和局部变量的规则定义了一种空间层次。每个声明区域都可以声明名称，这些名称独立于其他在声明区域中声明的名称

### 名称空间特性

可通过定义一种新的声明区域来创建新的名称空间。

一个名称空间中的名称不会与其他名称空间的相同名称发生冲突

程序的其他部分使用该名称空间中声明的东西。

名称空间可以是全局的，也可以位于名称空间中（名称空间可以嵌套），但不能位于代码块中。

默认情况下，在名称空间中声明的名称的连接性为外部的（除非它引用了常量）

除了用户定义的名称空间外，还存在另外一种名称空间——全局名称空间。对应于文件级声明区域。

前面所说的全局变量被描述为位于全局名称空间中。

名称空间中的定义规则同全局规则和定义规则相同。

名称空间是开放的：可以把名称加入到已有的名称空间中。

可以在名称空间中，使用using编译指令和using声明。

可以给命名空间创建别名。
~~~ cpp
namespace my_very_favorite_thing {...};
namespace mvft = my_very_favorite_thing;
~~~

别名可以简化对嵌套命名空间的调用

~~~ cpp
namespace MEF = myth::elements::file;
using MEF::flame;
~~~

可以通过省略名称空间的名称来创建未命名的名称空间。

~~~ cpp
namespace
{
    int ice;
    int bandycot;
}
~~~

不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。

未命名的名称空间提供了链接性为内部的静态变量的替代品。

~~~ cpp
static int counts;
//等效于
namespace 
{
    int counts;
}
~~~



### 访问名称空间

1. 使用作用域解析运算符`::`
   未被装饰的名称成为未限定的名称，
   包含名称空间的名称成为限定的名称。
2. `using`声明和`using `编译指令
   - `using`声明使特定的标识符可用，由被限定的名称和它前面的关键字`using`组成
   - `using `编译指令使整个名称空间可用，将特定的名称添加到它所属的声明区域中。由名称空间名和它前面的关键字`using namespace`组成。
3. `using`声明和`using `编译指令的比较。P269
   `using `编译指令更像是大量使用作用域运算符，使用`using`声明就像声明相应的名称。

 ### 名称空间的指导规则

使用名称空间是简化大型变成项目的管理工作。

P274

***

# 对象和类

OOP特性：

- **抽象** [[C++学习笔记#抽象和类]]
- **封装和数据隐藏**[[C++学习笔记#封装]]
- **多态**
- **继承**[[C++学习笔记#类继承]]
- **代码的可重用性**

在C++中，**用户定义类型** 指的是实现抽象借口的类设计。

## 抽象和类

类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。

类的规范由两个部分组成：（即指定类设计）

- 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述共有接口
- 类方法定义：描述如何实现类成员函数。

C++将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码中。

类名首字母通常大写

**定义类**：`class`关键字

要执行的操作以**类函数**成员的形式出现，成员函数可以就地定义，也可以用原型描述。

类可以将**数据**和**方法**（函数）组合成一个单元。

### 访问控制

**访问控制关键字** `private`, `public` 描述了对类成员的访问控制。

使用类对象的程序都可以直接访问共有对象，但只有通过**共有成员函数（或友元函数）** 来访问对象的私有成员。

公有成员函数提供了对象和程序之间的接口

防止程序直接访问数据被称为数据隐藏。

类设计应尽可能将共有接口与实现细节分开

共有接口表示设计地抽象组件。

### 封装

将实现细节放在一起并将他们与抽象分开被称为**封装**。

**封装：**
- 数据隐藏
- 将实现地细节隐藏在私有部分中
- 将类函数定义和类声明放在不同的文件中。

无论类成员是数据成员还是成员函数，都可以在类的共有部分或私有部分中声明它。但处于数据隐藏的目标，通常数据项放在私有部分，组成类接口放在共有部分。

私有成员函数处理不属于公有接口的实现细节。

`private` 是类对象的默认访问控制，因此是可选的。

**类和结构的唯一区别：** 结构的默认访问类型为`public`，而类为`private`。

### 实现类成员函数

成员函数定义与常规函数定义十分相似，有函数头和函数体，也可以有返回类型和参数。

但成员函数定义独有的特征：

- 定义成员函数时，使用作用域解析运算符 `::` 来标识函数所属的类。
	- 因此可以命名同名而不同类的成员函数。
	- 作用域解析运算符 `::` 确定了方法定义定义对应类的身份。
	- 类方法的完整名称包括类名。`class_name::f_name()` 是函数的**限定名** ；`f_name()`是全名的缩写（非限定名），只能在类作用域中使用。
- 类方法可以访问类的 `private` 组件（私有成员）。
	- 编译器禁止使用非成员函数访问类的私有成员。（友元函数除外）

**内联方法：**

定义位于类声明中的函数都将自动成为内联函数。

类声明之外的成员函数可以作为内联函数：加上 `inline` 限定符即可。


改写规则：在类声明中定义方法等同于用原型替换方法定义，但后在类声明的后面将定义改写为内联函数。

**类成员函数的使用：**声明的对象名加上`.`再加上类成员函数名。

**注意：** 对象使用成员函数，成员函数隐式地使用调用函数地对象。如果函数的参数中有对象参数，则时显式地使用作为参数传递的对象。

#### 静态成员函数

可以将函数成员声明为静态的（函数声明必须包含关键字 `static`，但如果函数定义 i 是独立的，则其中不能包含关键字 `static`）

影响：
- 不能通过对象调用静态成员函数
  - 静态成员函数不能使用 `this` 指针
  - 如果静态成员函数实在共有部分声明的，则可以使用类名和作用域解析运算符来调用它。
- 静态静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
  - 也可以使用静态成员函数设置类级标记，以控制某些类接口的行为。

## 类的构造函数和析构函数。

应为类提供被称为构造函数和析构函数的标准函数。

类构造函数：专门用于构造新对象、将值赋给类的数据成员。

构造函数没有声明类型。没有声明类型，原型位于类声明的公有部分。

构造函数的参数表示的不是类成员，而是赋给类成员的值，因此参数名不能与类成员相同。一种常见的做法是在数据成员名中使用`m_`前缀，另一种常见的作法是使用后缀`_`

### 使用构造函数

#### 使用方法

1. **显式**地调用构造函数
   ~~~ cpp
   Stock food = Stock("Furry Mason",50,2.5);
   ~~~

2. **隐式**地调用构造函数
   ~~~ cpp
   stock garment("Furry Mason",50,2.5);
   //与下面的语句等价
   Stock garment = Stock("Furry Mason",50,2.5);
   ~~~

每次**创建类对象**时（甚至使用 `new` 动态分配内存），C++都是用类构造函数。

将 `new` 与构造函数一起使用：

~~~ cpp
Stock *pstock = new Stock("Electroshock Games",18,19.0);
~~~

这种情况下，对象没有名字，但可以使用**指针**来管理该对象。

无法通过对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。

因此构造函数被用来**创造对象**，而不能通过对象来调用。

#### 构造函数原理

调用构造函数时，对象将在构造函数括号中的代码执行之前被创建。

即，构造函数会首先给类对象的成员分配内存，然后程序流程进入括号中，使用**常规赋值方式**将值存储到内存中。

这将导致 `const` 成员初始化的问题，所以要在程序执行到构造函数体之前（创建对象时）进行初始化。C++可以使用初始化器来解决。


##### 初始化器（成员初始化列表）

成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）
它位于参数列表的右括号之后、函数体左括号之前
初值可以是常量或构造函数的参数列表中的参数。这种发方法不限于初始化变量，但只有**构造函数**才能使用这种初始化列表语法。
- 对于 `const` 成员和被声明为**引用**的类成员必须使用这种语法。
  因为引用与 `const` 数据，只能在被创建时进行初始化。
- 对于简单数据成员，使用成员初始化列表和在函数体中使用赋值没有什么区别。
- 对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。

==**语法**== ：如果 `Classy` 是一个类，而 `mem1`、`meme2` 和 `mem3` 都是这个类的数据成员。
```cpp
Classy::Classy(int n,int m):mem1(n),mem(0),mem3(n*m + 2)
{
//...
}
```

###### 成员初始化列表
派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数
```Cpp
derived::derived(type1 x,type2 y):base(x,y)
{
//...
}
```

其中，`derived`是派生类，`base`是基类，`x`和`y`是基类构造函数使用的变量。
##### C++11 的类内初始化

```cpp
class Classy
{
	int mem1 = 10;
	const int mem2 = 20;
	//...
}
```

C++11可以像这样更直观的方式进行初始化，这与在构造函数中使用成员初始化列表等价

### 默认构造函数

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数：

~~~ cpp
Stock fluffy_the_cat;
~~~

如果没有提供任何构造函数，则 C++将自动提供默认构造函数。它是默认构造函数地隐式版本，用作任何工作。

在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。

## this指针
`this` 指针指向用来调用成员函数的对象（this 作为隐藏参数传递给方法）。


## 对象数组

## 类作用域

在类中定义的名称的作用域都为整个类，作用域为类的名称只在该类中是已知的，在类外是不可见的。

类作用域意味着不能从外部直接访问类的成员，公有函数成员也是如此。

因此，调用公有函数成员必须通过对象。

同样，在定义成员函数时，必须使用作用域解析运算符。

在类声明或成员函数定义中，可以使用未修饰的成员名称（未限定的名称）

构造函数名称在被调用时，才被识别，因为它的名称与类名相同。

使用类成员名时，必须根据上下文使用直接成员运算符（`.`）、简介成员运算符（`->`）、或作用域解析运算符（`::`）

### 作用域为类的常量

使符号常量的作用域为类很有用。

**注意：** 声明类只是描述了对象的形式，并没有创建对象。
在创建对象前，将没有储存值的空间。
（C++提供了![[成员初始化]]）

**创建方式：**
1. **在类中声明一个枚举。**
   - 注意：用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。
   - 当编译器在作用域为类的代码中遇到以这种方式创建的枚举时，将会以 `数值` 取代。
   - 此处使用枚举是为了创建符号常量，并不打算创建枚举型的变量，因此不需要提供枚举名。
   - 代码：
     ~~~ cpp
     class Ba
     {
     private: 
	     enum {Months = 12};
	     double costs[Months];
	     ...
     }
     ~~~

2. **使用关键字 `static`**
   - 代码：`static const int Months = 12//在类的私有成员中;`
   - 该常量将与其他静态变量储存在一起。而不是存储在对象中。
   - 在 C98 中，只能声明值为**整形**或**枚举**的静态变量。
   - C++11取消了上述限制。

### 作用域内枚举
传统的枚举：两个枚举定义中的枚举量可能会出现发生冲突，导致无法通过编译。
C++11 提供了一种新枚举，其枚举量的作用域为类。
例：
~~~ cpp
enum class egg {small, Medium, Large, Jumbo};
enum class t_shirt{Small, Medium, Large, Xlarge};
~~~

可以用 `struct` 代替 `class`。但是都得用枚举名来**限定**枚举量：
~~~ cpp
egg choice = egg::Large;
~~~

枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生冲突了。
C++11 提高了作用域内枚举的类型安全，在作用域内的枚举不能隐式地转换为整形，但在必要时，可以进行显式类型转换。

**枚举用某种底层整型类型表示**，在 c++98 中，如何选择取决与实现，因此包含枚举地结构地长度可能随系统而异。
罪域作用域内枚举，C++11 取消了这种依赖：
在默认情况下，C++11 作用域内枚举地底层类型为 `int`。
还可以**指定**底层类型：
~~~ cpp
enum class : short pizza {Small, Medium, Large, Xlarge};
~~~
`short` 将底层类型指定为 `short`。底层类型必须为整形。在 C++11 中，也可以使用这种语法来指定常规枚举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。


## 运算符重载

#运算符重载

运算符重载是一种形式的C++多态。

运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。

C++更具操作数的数目和类型绝地给采用哪种操作。

C++允许将重载扩展到用户定义的类型。

运算符重载使得语句隐藏了内部机理，并强调了实质。

使用重载：

要重载运算符，就得使用被称为运算符函数的特殊函数形式：

~~~ cpp
operatorop(argument-list);
//例：重载+运算符
operator+();
~~~

**注意：** 运算符函数地特殊函数形式，使得可以使用函数表示法或运算符表示法来调用它。编译器将根据操作数的类型来确定如何做.

比如说重载了+运算符：
~~~ cpp
int a,b,c;
Time A,B,C;
c=a+b;
C=A+B;
~~~

重载了+运算符之后，可以将两个以上的对象相加。

~~~ cpp
t4 = t1 +t2 +t3;
~~~

上述语句会被转换为函数调用：

~~~ cpp
//第一步：加法运算符从左向右结合
t4 = t1.operator+(t2+t3);
//第二步: 参数本身被转换为一个函数调用
t4 = t1.operator+(t2.operator+(t3));
~~~

也就是说，重载后的运算符左侧必须是使运算符重载的类。

因为最后编译器要将转换重载运算符为成员函数调用。

### 重载限制


==**运算符重载限制：**==

1. 重载的运算符不必是成员函数，但必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。
2. 使用运算符时不能违反运算符原来的句法规则。不能修改运算符的优先级
3. 不能创造新的运算符
4. 不能重载下面的运算符 
   - `sizeof`:sizeof运算符。
   - `.`:成员运算符。
   - `.*`：成员指针运算符。
   - `::`：作用域运算符。
   - `?`：条件运算符。
   - `typeid`：一个RTTI运算符。
   - `const_cast`：强制类型转换运算符。
   - `dynamic_cast`：强制类型转换运算符。
   - `reinterpret_cast`：强制类型转换运算符。
   - `static_cast`：强制类型转换运算符。
5. 下列的运算符只能通过成员函数进行重载：
   - `=`：赋值运算符
   - `()`：函数调用运算符
   - `[]`：下标运算符
   - `->`：通过指针访问类成员运算符
## 友元



- 友元有三种：
	- [[C++学习笔记#友元函数|友元函数]]
	- [[C++学习笔记#友元类|友元类]]
	- [[C++学习笔记#友元成员函数|友元成员函数]]

友元声明可以位于公有、私有或保护部分。

通过将函数称为类的友元，可以赋予该函数与类的而成员函数相同的访问权限。

友元函数没有非成员函数的限制，可以访问私有成员。同时又能像非成员函数那样可以按所需的顺序获得操作数。

类的友元函数是非成员函数，其访问你权限与成员函数相同。

在重载二元运算符时常常需要友元。

非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。

使用非成员函数函数可以按所需的顺序获得操作数。

### 友元函数

***创建友元函数：***
1. 将其原型放在类中，并在原型声明前加上关键字`friend`。
   ~~~ cpp
   friend Time operator*(double m,const Time & t );
   ~~~
   - 虽然 ` opreator*()` 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
   - 虽然 ` operator*()` 函数不是成员函数，但它与成员函数的访问权限相同。
2. 编写函数定义。因为它不是成员函数，所以不需要加上类名和解析运算符限定。且不要在定义中使用`friend`。
   ~~~ cpp
   Time::operator*(double m,const Time & t )
   {
      Time result;
      long totalminutes = t.hours * m * 60 + t.minutes *m;
      result.hours = totalminutes /60;
      result.minutes = totalminutes % 60;
      return result;
   }
   ~~~

#### 友元说明

应将友元函数看作类的扩展接口的组成部分，而不应人为将友元函数与OOP数据隐藏的原理相悖。

只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了那些函数可以访问私有数据。

类方法和友元只是表达类接口的两种不同机制。

#### 常用的友元：重载 `<<` 运算符

一个很有用的类特性是，可以对`<<`运算符进行重载，使之能与`cout`一起来显示对象的内容。

如何声明？通过`Time`类声明来让`Time `类知道如何使用`cout`。

1. **第一种版本**。
   
   使用友元函数

   ~~~ cpp
   void operator<<(ostream &os,const Time &t)
   {
      os<<t,hours << " hours, " <<t.minues <<"minutes";
   }
   ~~~

   后可以使用：`cout<<trip`

   该函数不是ostream类的友元。

   调用`cout<<trip`应使用cout对象本身，而不是它的拷贝，因此该函数按引用传递该对象。

2. **第二种版本**。
   第一种版本不能使用复杂的`cout`显示：
	~~~ cpp
	cout<<"Trip time: "<< trip << " (Tuesday)\n";
	~~~
	
	实现这种功能只需让 `operator<<` 函数 返回一个指向调用对象（这里是`cout`）的引用：
	
	~~~ cpp
	ostream & operator<<(ostream & os,const Time & t)
	{
		os<<t,hours << " hours, " <<t.minues <<"minutes";
	}
	~~~
	
	返回类型是`ostream&`,这意味着该函数返回ostream对象的引用。函数开始执行时，传递给一个对象引用给他，这样做的结果是，函数的返回值就是传递给它的对象。
	
	~~~ cpp
	cout << trip;
	~~~
	
	将被转换为：
	
	~~~ cpp
	operator<<(cout, trip);
	~~~
	
	该调用返回 `cout`对象。因此一开始的语句可以运行。

### 友元类

将另一个类加上 `friend` 关键字加入到另一个的类定义中即可

友元声明可以位于公有、私有或保护部分，声明位置不重要。



```cpp
class A
{
	private：
		//...
	public:
		//...
		friend class B;
};
class B
{
	//...
};
```

### 友元成员函数

当声明位置在前面的类需要使用声明在后面的类时需要使用前向声明


**前向声明**：

### 其他友元关系
1. 两类互为友元
	1. 两类互为友元时，两类方法互相调用时应如何处理
	   - 保证有声明在调用之前，以及在调用之后有定义
2. 两类有共同的友元
	- 共同的友元机制是为了处理函数需要访问两个类的私有数据的问题
	- 一个类的成员，另一个类的友元
	- 将函数作为两个类的友元


## 嵌套类

在另一个类中声明的类被称为嵌套类。

作用：通过提供新的类型类作用域来帮助实现另一个类，并避免名称混乱。

嵌套与包含不同。对类嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。

嵌套了结构定义，从而实现了一种变相的嵌套类。因为结构是一种其成员在默认情况下为共有的类。

### 嵌套类和访问权限

类声明的位置决定了类的作用域或可见性。类可见后，访问控制规则（公有、私有、保护、友元）将决定程序对嵌套类成员的访问权限。

两种访问权限：
- 作用域
	- 嵌套类的声明位置决定了嵌套类的作用域，即它决定了程序的哪些部分可以创建这种类的对象
	- 如果嵌套类是在另一个类的私有部分声明的，则只有后者知道他。
	- 如此等等，与普通的类成员一样
	- 嵌套类、结构类和枚举的作用域特征
	  
	  | 声明位置 | 包含它的类是否可以使用它 | 从包含他的类派生而来的类是否可以使用它 | 在外部是否可以使用 |
	  | -------- | ------------------------ | -------------------------------------- | ------------------ |
	  | 私有部分 | 是                       | 否                                     | 否                 |
	  | 保护部分 | 是                       | 是                                     | 否                 |
	  | 共有部分 | 是                       | 是                                     | 是，通过类限定符来使用                   |
- 访问控制
	- 嵌套类的共有部分、保护部分和私有部分控制了对类成员的访问
	- 类可见后，起决定作用的是访问控制。

### 模板中的嵌套类

## 类的自动转换与强制转换

C++语言不自动转换不兼容的类型。

可以将类定义成与基本类型成另一个类相关，使得从一种类型转换为另一种类型是有意义的。在这种情况下，程序员可以只是C++如何自动进行转换，或通过强制类型转换来完成。

C++ 提供了下面的类型转换：

- 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。
- 被称为==**转换函数**== 的特殊类成员运算符函数，用于将类对象转换为其他类型。

**注意：** 在使用转换函数时，必须注意是否与其他定义的函数发生二义性。
**注意：** 一定要理解，在运用转换函数时，背后的转换机制（函数调用）

**对于定义类特定的常量**，**如果他们是整数**：
1. `enum`
   ~~~ cpp
	enum {Lbs = 14};
	~~~
2. `static`
	~~~ cpp
	static const int Lbs = 14;
	~~~ 

在C++中，接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。

~~~ cpp
//stonewt.h
#ifndef STONEWT_H_
#define STONEWT_H
class stonewt
{
private:
enum {Lbs_per_stn = 14};int stone;
double pds_left;double pounds;public:
stonewt (double lbs);
stonewt(int stn, double lbs);stonewt ( ) ;
~stonewt ( );
void show_lbs( ) const;void show_stn( ) const;y;
#endif
~~~


### 转换构造函数： 利用构造函数实现转换

任何接受唯一一个参数的构造函数都可被用做转换函数，将类型与该参数相同的值转换为类。

如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。

如果在该构造函数的声明前加上了关键字 `explicit`，则该构造函数只能那个用于显式转换。C11新添加的特性。

**具体说明：**

下面的构造函数用于将double类型转换为Stonewt类型：
~~~ cpp
stonewt (double lbs);
//转换实例：
stonewt myCat；
myCat = 19.6;
~~~
程序说明：

程序将使用构造函数来创建一个临时的队形，并将19.6作为初始化值。

随后，采用逐成员赋值方式将该临时对性的内容赋值到myCat中。

这一过程成为==**隐式转换**==。

==**隐式转换**==：
- 将`stonewt`对象初始化为`double`值时。
- 将`double`赋给`stonewt`对象时。
- 将`double`值传递给接受`stonewt`参数的函数时
- 返回值被声明为`stonewt`的函数试图返回`double`值时。
- 在上述任意一种情况下，使用可转换为double类型的内置函数时。

因为它是自动进行的，不需要显示强制类型转换。

函数原型化提供的参数匹配过程，允许使用`stonewt (double)`构造函数来转换其他数值类型，当且仅当转换不存在二义性时：
~~~ cpp
stonewt Jumbo(7000);       //使用stonewt (double)
Jumbo = 7300;              //使用stonewt (double)
~~~
如果又定义了`stonewt (long)`转换函数，编译器将拒绝这些语句，因为`int`类型可以被转换为`long`或`double`，调用存在二义性。
**只有接受一个参数的构造函数才能作为转化函数。**

**注意：** 只接受一个参数的构造函数定义了从参数类型到类类型的转换。

隐式转换会导致意外的类型转换。

`explicit`用于关闭这种自动特性(隐式转换)：

~~~ cpp
explicit stonewt (double lbs);
~~~

但仍然允许显示转换，即显式强制类型转换。：
~~~ cpp
stonewt myCat;
myCat = 19.6;
myCat = stonewt(19.6);
myCat = (stonewt) 19.6;  //or
~~~



### 转换函数

> 构造函数只用于从某种类型到类类型的转换。
> 要实现从类类型到特定类型的转换，必须使用特殊的C++运算符函数： ==**转换函数**==

==**转换函数**== **：** 是用户 定义的强制类型转换，可以向使用强制类型转换那样使用它们。

**创建转换函数：**

~~~ cpp
operator typeName();
//例：
operator int();
~~~

`typeName`指出了对象要被转换成的类型，因此不需要返回类型。

将类对象赋给`typeName` 变量，或将其强制转换为`typeName` 类型时，该转换函数将自动被调用。


**注意：**
- 转换函数必须是类方法；
  - 因此需要通过类对象调用，从而告知函数要转换成的值。
  - 因此，函数不需要参数。
- 转换函数不能指定返回类型；
  - 但必须返回转换后的值，虽然没有声明返回类型。
- 转换函数不能有参数；

### 转换函数和友元函数

P341

**实现加法时的选择**

通过人为分析，添加匹配的函数，使得程序的运行速度加快。
不能过度依赖隐式转换。

***

# 类和动态内存分配

## 动态内存和类

### 静态类成员

静态数据成岩在类声明中声明，在包含类方法中的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是`const`整数类型或枚举型，则可在类声明中初始化。

特点：程序只有一个静态类变量副本，即类的所有对象共享同一个静态成员。

初始化例子:
```cpp
int class_name::static_num1 = 0;
```

其中使用了作用域运算符，但没有关键字 `static`。



## 特殊成员函数

**C++自动提供下面这些成员函数：**

- 默认构造函数，如果没有定义构造函数；
- 默认析构函数，如果没有定义；
- 复制构造函数，如果没有定义；[[C++学习笔记#复制构造函数]]
- 赋值运算符，如果没有定义；
- 地址运算符，如果没有定义；
 
 更准确的说，编译器将生成上述最后三个函数的定义——如果程序适用对象的方式要求这样做。



 **C++11新增：**

- 移动构造函数
- 移动赋值运算符

### 默认构造函数

带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。

只能有一个默认构造函数。

### 复制构造函数

**类的复制构造函数原型：**

~~~ cpp
Class_name(const Class_name &)
~~~

**用途：** 复制构造函数用于将一个对象复制到新创建的对象中

#### 复制构造函数何时调用

**何时调用：**
- 将新对象初始化为一个同类对象
- 按值将对象传递给函数
- 函数按值返回对象
- 编译器生成临时对象

**调用说明：**
用于**初始化** 过程中（包括按值传递参数），而不是常规的复制过程中。**即：** 新建一个对象并将其初始化为**同类现有对象**时，复制构造函数都将被调用。这个过程是**显式** 的。

声明时调用的 4 种场景：
~~~ cpp
stringBad ditto(motto);
StringBad metoo = motto;
String also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto)
~~~
中间的2种声明可能会使用复制构造函数直接创建metoo 和also也可能使用复制构造函数创建一个临时变量，然后将临时变量内容赋给metoo和also，这取决于具体的实现。最后一种声明使用`motto`初始化了一个匿名对象，并将新对象的地址赋给`pStringBad`。

**==每当程序中生成了对象副本时，编译器都将使用复制构造函数==**。

当函数按值传递对象或函数返回对象时，也将使用复制构造函数，生成临时对象的时机因编译器而异。

由于按值传递对象将调用复制构造函数，因此应该按**引用**传递对象。这样可以节省调用构造函数的时间以及储存新对象的空间。

#### 默认的复制构造函数的功能

默认的复制构造函数逐个复制非静态成员（成员复制也叫==**浅复制**==），复制的是成员的值。如果成员本身就是类对象，则将使用这个类的复制构造函数来复制类成员。

隐式复制构造函数是按值复制的，如果其中有指向字符串的指针，复制的只是指针的地址，复制完后，两个对象当中的这个指针，指向同一个字符串。但是如果成员指向的内存被释放的话，这将导致不确定的、可能有害的后果。**这是内存管理不善的表现**。而且，指向同一个内存有可能析构函数会将同一块内存**释放**两次而导致程序意外终止。

==解决问题：== 定义一个**显式**复制构造函数。

解决类设计中这种问题的方法时进行**深度复制**。

必须定义复制构造函数的原因在于，一些类成员是使用`new`初始化的、指向数据的指针，而不是数据**本身**。

如果类中包含了使用 `new` 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据。而不是指针，这被称为**深度复制**。

### 赋值运算符
C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。

运算符原型：
```cpp
Class_name & Class_name::operator=(const Class_name &);
```
这个原型接受并返回一个指向类对象的引用。
**何时调用：**
1. 将已有的对象赋给另一个对象时，将会使用重载的赋值运算符。
2. 初始化对象时，并不一定会使用赋值运算符。有可能会使用复制构造函数。

==**如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值。**==

赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的复制运算符来复制该对象，但静态数据成员不受影响。

对于由于默认复制运算符不合适而导致的问题，解决办法是提供复制运算符（进行深度复制）定义。

与复制构造函数的差别：
- 由于目标对象可能引用了以前分配的数据，所以函数应使用 `delete[]` 来释放这些数据
- **函数应当避免将对象赋给自身**；否则，给对象重新赋值，释放内存操作可能删除对下个你的内容。
- 函数返回一个指向调用对象的**引用**。                                

通过返回一个对象，函数可以向常规赋值操作那样，**连续进行赋值**。

```cpp
class_name & class_name::operator=(const class_name & cn)
{
	if(this == &cn)
		return *this;
	delete [] str;		//清除旧的类成员
	//分配空间
	//复制操作
	return *this;
}
```

指针指向的内存如果不再被使用时或指向应释放掉。

赋值操作并不创建新对象。

## 在构造函数中能够使用`new`时的应注意的事项。

要时刻 **注意** 在构造函数和析构函数中：
1. `new`和`delete`要成对使用。
2. `new`和`delete`的使用方式应一致，即`[]`的使用应一致。

**具体地说，应该这样做：**（尤其是在其构造函数中使用`new`的类）
- 如果在构造函数中使用`new`来初始化指针成员，则应在析构函数中使用`delete`。
- `new`和`delete`必须互相兼容。`new`对应`delete`，`new[]`对应于`delete[]`。
- 如果有多个构造函数，则必须以相同的方式使用`new`,要么都带中阔号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与他兼容。然而，可以在一个狗在函数中使用`new`初始化指针，而在另一个构造函数中将指针初始化为**空**，这是因为`delete`（不带`[]`或带`[]`）可以用于空指针。
- 应定义一个**复制构造函数**，通过深度复制将一个对象初始化为另一个对象
	- 复制构造函数应**分配足够的空间来复制储存赋值的数据，并复制数据**，而不仅仅是数据的地址。另外，还应更新所有受影响的静态类成员。
	- 代码：
		``` cpp
		String::String(const String & st)
	      {
	         num_string++; //更新静态成员
	         len = st.len;
	         str = new char [len+1];//分配空间
	         std::strcpy(str,st.str);//复制字符串
	      }
		  ```
- 应定义一个**赋值运算符**，通过深度复制将一个将一个对象复制给另一个对象
	**完成的功能：**
	- 检查自我赋值情况
	- 释放成员指针以前储存的内存，复制数据而不仅仅是数据的地址
	- 返回一个指向调用对象的引用。
	- 代码
	~~~ cpp
	  String::String(const String & st)
	  {
		 if(this == &st)
		 return *this;
		 delete [] str;
		 len = st.len;
		 str = new char [chat + 1];
		 std::strcpy(str,st.str);
		 return *this;
	  }
	~~~

## 有关返回对象的说明

成员函数或独立的函数返回对象时的返回方式：
- 返回指向对象的引用
- 指向对象的`const`引用或`const`对象

> 如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对象。如果方法或函数返回一个没有公有赋值构造函数的类（如`ostream`）的对象，他必须返回一个指向这种对象的引用。最后有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。

### 返回指向 `const` 对象的引用
使用 `const` 引用旨在提高效率（主要原因）。

**限制：** 函数返回（通过调用对象的方法或将对象作为参数）传递个它的对象

**说明：** 

1. 返回对象将会调用复制构造函数，但返回引用不会。
2. 引用指向的对象应在调用函数执行时存在。
3. 若参数中都被声明为 `const` 引用，则返回类型必须为 `const`，这样才匹配。

### 返回指向非 `const` 对象的引用

情形：
- **重载** 赋赋值运算符（目的：提供效率）
- 重载与`cout`一起使用的`<<`运算符。（必须这样做）


### 返回对象

如果返回的对象时被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。

在这种情况下，存在调用复制函数来创建被返回的对象的开销，然而这是无法避免的。

### 返回 `const` 对象

防止复制构造函数创造的临时对象引发误用。

总之，如果有对象或函数要返回局部对象，则应返回对象，而不是指向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对象。如果方法或函数要返回一个没有公有复制构造函数的类的对象，他必须返回一个指向这种对象的引用。最后，有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，在这种个情况下，应首先引用，因为其效率更高。

## 使用指向对象的指针

**使用 `new` 初始化对象**:
通常，如果 `CLass_name` 是类，`value` 的类型为 `Type_name` 则下面的语句：
```cpp
Class_name * pclass = new Class_name(value);
```
将调用如下构造函数：
```cpp
Class_name(Type_name);
```

还可能转换：
```cpp
Class_name(const Type_name &);
```
如果不存在二义性，则将发生由原型匹配导致的转换。
下面的初始化方式将调用默认构造函数
```cpp
Class_name * ptr = new Class_name;
```


在下述情况下析构函数将被调用：
- 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数
- 如果对象是静态变量（外部、静态、静态外部变量或来自名称空间），则在程序结束时将调用对象的析构函数。
- 如果对象是用 `new` 创建的，则仅当显式使用 `delete` 删除对象时，其析构函数才会被调用。

**小结：** 
- 使用常规表示法来声明指向对象的指针
- 可以将指针初始化为指向已有的对象
- 可以使用 `new` 来初始化指针，这将创建一个新的对象。
- 对类使用 `new` 将调用相应的类构造函数来初始化新创建的对象。
- 可以使用 `->` 运算符通过指针访问类方法。
- 可以对对象指针应用解除引用运算符 `*` 来获得对象。




## 队列模拟
[[队列模拟]]

# 类继承

**类继承的功能：**
- 可以在已有类的基础上添加功能
- 可以给类添加数据
- 可以修改类方法的行为

继承机制只需提供新特性，甚至不需要访问源代码就可以派生出类。

从一个类派生出另一个类时，原始类成为基类。


派生类和基类之间的特殊关系基于 C++继承的底层模型

## 继承
- **继承方式**：
	- [[C++学习笔记#公有继承|公有继承]]
	- [[C++学习笔记#保护继承|保护继承]]
	- [[C++学习笔记#私有继承|私有继承]]

继承可以在基类的基础上添加属性，但不能删除基类的属性。

- 各种继承方式的区别：
| 特征             | 公有继承             | 保护继承               | 私有继承             |
| ---------------- | -------------------- | ---------------------- | -------------------- |
| 公有成员变成     | 派生类的公有成员     | 派生类的保护成员       | 派生类的私有成员     |
| 保护成员变成     | 派生类的保护成员     | 派生类的保护成员       | 派生类的私有成员     |
| 私有成员变成     | 只能通过基类接口访问 | 只能通过基类接口访问   | 只能通过基类接口访问 |
| 能否隐式向上转换 | 是                   | 是（但只能在派生类中） | 否                     |

###  公有继承

 公有继承建立 `is-a` 关系：派生类对象也是基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。
 
 公有继承不建立 `has-a` 、`is-like-a` 、`is-implemented-a` 、`uses-a` 关系（可以，但会出问题）。
 
 公有派生：派生类对象包含基类对象。使用共有派生，基类的共有成员将成为派生类的公有成员。基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。

**派生类构造函数：**
- 首先创建基类对象。（意味着基类对象应当在进入派生类构造函数之前被创建）
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
- 派生类构造函数应**初始化派生类新增的数据成员**。[[C++学习笔记#成员初始化列表]]
- 如果没有提供显式（使用初始化器列表语法）构造函数，将使用默认的基类构造函数（隐式构造函数）
- 派生类的构造函数总是调用一个基类构造函数

**派生类和基类之间的特殊关系：**

- 派生类对象可以使用基类的方法（方法是非私有的）
- 基类指针可以在不进行显式类型转换的情况下指向派生类对象
- 基类引用可以在不进行显式类型转换的情况下引用派生类对象
	- 但基类指针或引用只适用于调用基类方法。
  - C++要求引用和指针类型与赋给的类型匹配，但这一规则继承来说是例外。但这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。


 
 #### 多态公有继承
 
 
 **实现多态公有继承的机制**：
 - 在派生类中重新定义基类的方法
 - 使用虚方法

如果没有使用关键字 `virtual`，程序将根据引用类型或指针类型选择方法。
如果使用关键字 `virtual`，程序将根据引用或指针指向的对象的类型来选择方法。
 经常在基类中将派生类重新定义的方法声明为虚方法。方法在基类中被声明为虚的后，它再派生类中间自动成为虚方法，也可以在派生类中使用关键字`virtual`来指出哪些函数是虚函数。
 
非构造函数不能使用成员初始化列表语法，但派生类方法可以调用共有的基类方法（使用作用域解析运算符来调用基类方法，代码也必须使用作用域解析运算符，如果没有作用域解析运算符，会创造一个不会终止的递归函数）。

**为何使用虚析构函数：**
使用虚析构函数可以确保析构函数序列可以被调用。
如果析构函数不是虚的，则将只调用对应指针类型的析构函数。如果析构函数是虚的，将调用响应对象类型的析构函数。


## 静态联编和动态联编

**函数名联编**：编译器将源代码中的函数调用解释为执行特定的函数代码块。

C/C++可以在编译过程中完成这种联编。

**联编的发展**：
1. **静态联编** ：（又称早期联编）在编译的过程中进行联编。
2. **动态联编**：（又称晚期联编），编译器在程序运行过程时选择正确的虚方法的代码。
   需要动态联编的理由：隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。

### 指针和引用类型的兼容性

在 C++中，动态联编与通过指针和引用调用方法相关，从某种程度上，这是由继承控制的。

公有继承建立 is-a 关系的一种方法是如何处理指向对象的指针和引用。
指向基类的引用或指针可以引用派生类，而不必进行显式类型转换。

**向上强制转换**：将派生类引用或指针转换为基类引用或指针被称为**向上强制转换**，这使公有继承不需要进行显式类型转换。该规则是 is-a 关系的一部分。
**向下类型转换**：将基类指针或引用转换为派生类指针或引用
如果不进行显式类型转换，则向下强制转换是不允许的。原因是 is-a 关系通常是不可逆的。
派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类。

### 虚成员函数和动态联编

1. 为什么会有两种类型的联编——效率和概念模型
	如果要在派生类中重新定义基类的方法，则将它设置为虚方法
	否则，设置为非虚方法
2. 虚函数工作原理
   编译器给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向指针数组的指针。这种数组没成为虚函数表（vtbl）。
   虚函数表中储存了为类对象进行声明的虚函数的地址。如果派生类提供了虚函数的新定义，该虚函数将保存新函数的地址；如果派生类没有重新定义虚函数，该 vtbl 将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到 vtbl 中。
   调用虚函数时，程序将查看储存在对象中的 vtbl 地址，然转向相应的函数地址。
3.   使用虚函数时，在内存和执行速度方面有一定的成本。
   - 每个对象都将增大，增大量为储存地址的空间。
   - 对于每个类。编译器都创建一个虚函数地址表（数组）
   - 对于每个函数低矮用，都需执行一项额外操作，即到表中查找地址。

虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。

### 有关虚函数注意事项
1. **构造函数** 
   构造函数不能是虚函数
2. **析构函数**
   析构函数应当是虚函数，除非不用做基类
3. **友元** 
   友元不能是虚函数，因为友元不是类成员。
4. **没有重新定义**
   如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本。
5. **重新定义将隐藏方法**
   重新定义继承的方法并不是重载，该操作将隐藏所有的同名基类方法
6. **经验原则**
   1. 如果重新定义基类的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改指向派生类的引用或指针（这种例外是新出现的）
      这种特性被称为返回类型协变，因为允许返回类型随类类型的变化而变化。
      这种例外只适用于返回值，而不适用于参数。
	2. 如果基类被重载了，则因在派生类中重新定义所有的基类版本
	   如果不需要修改，则新定义可只调用基类版本。


## 访问控制：`protected`

`protected` 表示：在类外只有公有类成员来访问 `protected` 部分中的类成员。

`protected` 和 `private` 的区别只有在继承时才会表现出来。
- 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
- 最好对类数据成员采用私有访问控制，不要使用保护访问控制
- 同时通过基类方法使派生类能够访问基类数据。


## 抽象基类（ABC）

C++通过纯虚函数提供为实现的函数。纯虚函数声明的结尾处为 `=0`
``` cpp
virtua double Area() const =0;
```

当类声明中包含纯虚函数时，则不能创建该类的对象。包含纯虚函数的类只用做基类。
要成为真正的 ABC，必须至少包含一个纯虚函数。圆形中的 `=0` 使虚函数成为纯虚函数。
C++甚至允许纯虚函数有定义。但使用`=0`指出类是一个抽象基类，在类中可以不定义该函数。

## 继承和动态内存分配

#### 1. 派生类不使用 `new`
派生类继承基类后，派生类不使用 `new`，继承来的字段由基类负责。

#### 2. 派生类使用 `new`

必须为派生类定义显示析构函数、复制构造函数和赋值运算符。


## 公有继承考虑因素
[[C++基类和派生类的特殊关系]]
1. **is-a 关系**
   - 表示 is-a 关系的方式之一是，无需进行显式类型转换，基类指针即可指向派生类对象，基类引用可以引用派生类对象。
    - 不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。
2. **什么不能被继承**
   - 构造函数
   - 析构函数
   - 赋值运算符
3. **赋值运算符**
   - 对于派生对象的基类部分，C++使用基类的运算符。
   - 如果派生类的类构造函数使用 `new` 来初始化指针，则需要提供一个显式赋值运算符。
     - 如果提供了，必须为类的每个成员提供赋值运算符，而不仅仅是新成员（应在函数中调用基类的显式赋值运算符）。
   - **将派生类对象赋给基类对象的情况**：
      - **可以将派生类对象赋给基类对象**，但这只涉及基类的成员，派生类对象的基类部分被复制给基类对象。
	   - **不同于**将基类引用初始化为派生类对象。
	   - **赋值语句原理**：赋值语句将被转换为左边的对象调用的一个方法。即处于右边的对象成为左边对象的方法的参数。
	- **将派生类赋给基类对象的情况**：
		   - **派生类引用不能引用基类对象**，但可以通过下列两种方法实现：
			- **方法 1.** **转换构造函数**
				   - 转换构造函数可以接受一个类型为基类的参数和其他参数（使用其他参数的条件是其他参数有默认值）。
				   - 个人感想：这种情况下，应该保证派生类对象中的成员都能被赋值。将新成员赋予默认值，这样也许可以防止一些不必要的错误。
			- **方法 2. **    定义一个用于将基类赋给派生类的赋值运算符。
					- 使用此方法可以不用进行类型转换。
4. **私有成员和保护成员**
   使用私有数据成员比使用保护数据更好，但保护方法很有用
5. **虚方法**
   - 设计类时，应该确定是否将类方法声明为虚的。
   - 是否启用虚函数代表了：
	   - 是否启用动态联编
	   - 是否希望方法被重新定义。
	- 不适当的代码将阻止动态联编。
6. 析构函数
   - 基类的析构函数应当是虚的。
7. 友元函数
   - 友元函数不是类成员，因此不能继承。
   - 在派生类中使用基类的友元函数：通过强制类型转换，派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数，也可以使用 `dynamic cast<>`

## 包含成员对象的类
### 初始化被包含的对象
- **方法**：使用成员初始化列表语法。
	- 对于成员对象构造函数在成员初始化列表中使用的是成员名，并在程序运行中调用与之匹配的构造函数。	
- **如果不使用初始化列表语法的情况**：
  - C++要求在构建对象的其他部分之前，先构建继承对象的所有成员对象。因此，C++将使用成员对象所属的默认构造函数。
- **初始化顺序**：
  - 当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。
### 使用被包含对象的接口
- 被包含对象的接口不是共有的，但可以在类方法中使用它们。通过成员对象调用成员对象的方法。
- 可以通过辅助私有方法，将零碎的细节放在一个地方，使得友元函数的编码更为整洁。
  - 辅助函数也可作为其他用户级输出函数的构建模块。

## 私有继承
私有继承用于实现 `has-a` 关系。私有继承获得实现但不获得接口。
- 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，即派生类不继承基类的接口。
- 使用私有继承，类将继承实现。将对象作为一个未命名的继承对象（子对象）添加到类中。
	- **子对象**：通过继承或包含添加的对象。


### 使用私有继承

使用关键字 `private` 定义类。`private` 是默认值，如果来定义时省略访问限定符也将导致私有继承。


### 初始化基类组件

使用成员初始化列表语法，使用**类名**标识构造函数。

### 访问基类的方法
- 访问限制 ^94ebcb
	- 只能在派生类方法中使用基类的方法。
	- 但可以使用类名和作用域解析运算符来调用基类方法

### 访问基类对象

方法：使用强制类型转换。（`this` 指针也可以被转转换）

### 访问基类的友元函数

方法：显示地转换为基类来调用正确的函数。

在私有继承中，未进行显示类型转换的派生类引用或指针，无法赋值给基类的引用或指针。

### 私有继承与包含的差别
- **私有继承与包含的差别：**
	- 提供的成员不同
		- 包含提供被显示命名的对象成员
		- 私有继承提供无名称的子对象成员
	- 初始化列表使用的名称不同
		- 包含使用的是对象成员名
		- 私有继承使用类名（注意名称空间和作用域解析运算符）
	- 访问基类的方法
		- 包含：使用对象名调用方法
		- 私有继承：![[C++学习笔记#^94ebcb]]

### 建立`has-a`关系使用包含还是私有继承（包含和私有继承地对比）

-  对比
   - 包含：
     - 易于理解
     - 类声明中包含被包含类地显式命名对象，代码可以通过名称引用这些对象。
     - 不能重新定义虚函数
   - 私有继承：
	   - 使关系更加抽象
	   - 私有继承可能会引起很多问题，尤其从多个基类继承时（如包含同名方法的独立地基类或共享祖先地独立基类）
	   - 可以提供更多特性：比如访问基类的保护成员。
	   - 可以重新定义虚函数
	- 结论：通常应使用包含建立`has-a`关系，如果新类需要访问原有类的保护乘员，需要重新定义虚函数，则应使用私有继承

### 保护继承
保护继承使私有继承的变体。保护继承在列出基类时使用关键字 `protected`

保护继承可以使用祖先基类的接口，而私有继承不能。

### 使用 `using` 重新定义访问权限

假设让基类方法在派生类外面可用的方法：
- 定义一个使用该基类方法的派生类方法。
- 将函数调用包装在另一个函数调用中，即使用一个 `using` 声明。来指出派生类可以使用特定的基类成员，即使采用的是私有派生。
	- using声明只使用成员名——没有圆括号、函数特征标和返回类型。

## 多重继承
MI 描述的是有多个直接基类的类。公有 MI 表示的是 `is-a` 关系。
必须使用关键字 `public` 来限定每一个基类。私有 MI 和保护 MI 表示 `has-a` 关系。

在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。
### 虚基类
虚基类使得从多个类（他们的基类相同）派生出的对象只继承同一个基类对象，其中 `virtual` 和 `public` 的顺序不影响声明效果。

### 新的构造函数规则

C++在基类是虚的时，禁止信息通过中间类自动传递给基类。因此，编译器将使用基类的默认构造函数。
如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。注意，这项操作对与虚基类来说是合法的，而对于非虚基类则是非法的。
如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。
### 使用哪个方法
- 问题：多重继承可能会导致函数调用的二义性。
	解决方法：
	1. 使用作用域解析运算符来澄清编程者的意图
	2. 在派生类中重新定义方法，并指出要使用哪个基类的方法。（此方法更好）

- 问题：多重继承地显式函数有可能显式重复信息
	解决方法：
	1. 使用模块化方式，而不是递增方式
	   每个模块只显示特定的内容，然后再派生类方法中组合起来。
	2. 将所有地数据组件都设为保护的，而不是私有的。使用保护方法将可以更严格地控制对数据的访问。

- 问题：混合使用虚基类和非虚基类的派生类继承问题
	- C++：当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。

- 问题：虚基类和支配：类从不同的类继承了两个或者更多的同名成员（数据或方法）怎么弄？
	1. 不使用虚基类，使用类名加以限定
		- 如果没有类名，将导致二义性。
	2. 使用虚基类将改变 C++解析二义性的方式。
		- 使用虚基类将不一定会导致二义性。C++使用优先判定
		- 优先：派生类中的名称优先于直接或间接祖先类中的相同名称
		- 虚二义性规则与访问规则无关。

# 模板
## 类模板
模板类使用下面的代码开头：类方法的函数头也应以同样的模板声明打头。
```cpp
template <class Type>
//or
template <typename Type>
```

当模板被调用时，Type 将被具体的类型值取代。Type 为泛型标识符又被称为类型参数。

模板类需要显式提供类型名。

### 正确使用指针栈
让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。

此时应当区分好职责。栈的职责是管理指针，而创建指针是程序的事。

### 非类型参数

**指定数组大小的模板的实现方法：**
1. 在类中使用动态数组和构造函数参数来提供元素数目
2. 使用模板参数来提供常规数组的大小

**非类型参数（表达式参数）** 指定特定的类型而不是用作泛型名。
注意：
- 可用作非类型参数的类型：整形、枚举、引用或指针。
- 模板代码不能修改该参数的值，也不能使用参数的地址。
- 实例化模板时，用作表达式参数的值必须是常量表达式

**非类型参数与构造函数方法区别：**
- 非类型参数
	- 非类型参数优点：
		- 表达式参数方法使用的是为自动变量维护的内存栈，执行速度更快。
	- 非类型参数类型缺点：
		- 每种数组大小都将生成自己的模板
- 构造函数
	- 优点：更加通用
	- 缺点：相较于栈内存，堆内存较慢

### 模板多功能性

可将用于常规类的技术用于模板类：
- 将模板类用做基类
- 组件类
- 其他模板的类型参数
	- 用作参数时，C++98 和 C++11 有格式差别：
	- `Array < Stack<int> > asi;` C++98 要求至少一个空白字符将两个 `>` 符号分开，以免与 `>>` 运算符混淆
	- C++11 则不要求这么做。
- 可以递归使用模板
	- `Array< ArrayTP<int,5>, 10> twodee;`
	- 注意，在模板语法中维的顺序与等价的二维数组相反
- 使用多个类型参数
	- 模板可以包含多个类型参数
- 默认模板参数
	- 可以为类型参数提供默认值
	- 类模板与函数模板区别:
		- 可以为类模板使用默认值，但不能为函数模板参数提供默认值
		- 但是两者都可以为非参数类型提供默认值。

### 模板的具体化

![[C++学习笔记#^098d72|具体化]]

模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。

1. **隐式实例化**
	- 编译器在需要对象之前，不会生成类的隐式实例化
2. **显式实例化**
   - 使用关键字 `template` 并指出所需类型来声明类
   - 声明必须位于模板定义所在的名称空间中。
   - 这种情况下，即使没有创建或提及类对象，编译器也将生成类声明（包括方法定义）
3. **显式具体化**
	- 是特定类型（用于替换模板中的泛型）的定义。
	- 用途：在为特定类型修改模板时。
	- 定义格式：
	  ```cpp
	  template <> class Classname<specialized-type-name> {}
	  ```
	  早期类型：(不包括前缀`template <>`)
	  ```cpp
	  class Classname<specialized-type-name> {}
	  ```
4. **部分具体化**
   - 部分限制模板的通用性

### 成员模板

模板可用作结构、类或模板类的成员。（实现 STL 必须使用这项特性）

### 将模板用于参数

模板还可以包含本身就是模板的参数。

可以混合使用模板参数和常规参数。

### 模板和友元

模板的友元分为 3 类
- 非模板友元
- 约束模板友元，即友元的类型取决于类被实例化时的类型
- 非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元。

####  模板类的非模板友元函数

没有对象参数的非模板友元函数如何访问模板类对象？几种可能：
1. 可以访问全局对象
2. 可以使用全局指针访问非全局对象
3. 可以创建自己的对象
4. 可以独立访问独立于对象的模板类的静态数据成员

如果要为友元函数提供模板类参数，必须指明具体化。

#### 模板类的约束模板友元函数

在类外面声明的模板的具体化

1. 在类定义的前面声明每个模板函数
2. 在函数中再次将模板声明为友元
3. 程序必须满足的第三个要求，为友元提供模板定义

#### 模板那类的非约束模板友元函数

通过在类内部声明模板，可以创建非约束友元函数。

#### 模板别名

关键字 `typedef`

`using=` ：
- 用于模板
- 用于非模板
---

# 异常

异常的出现是为了解决运行阶段错误，是程序可以正常运行下去。

## 异常终止：调用函数

### `absort()`

包含头文件 `cstdlib` 或 `stdlib.h`。

其典型实现是向标准错误流（即 `cerr` 使用的错误流）发送消息 `abnormal program termination`（程序异常终止），然后终止程序。还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程），处理失败。

`absort()` 是否刷新文件缓冲区取决于实现。

### `exit()`

刷新文件缓冲区，但不显示消息。

## 返回错误码-使用函数的返回值

优点：比异常终止灵活

可以使用指针参数或引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败

通过告知程序是成功了，还是结束了，使得程序可以采取除异常终止程序之外的其他措施。

实现：
- 使用指针参数或引用参数将值返回给调用程序，并使用函数的返回值来指出成功还是失败
- 在某一个地方储存返回条件的方式是使用一个全局变量。可能问题的函数可以再出现问题是将该全局变量设置为特定的值，而调用程序可以检查该变量。


## 异常机制

异常提供了将控制权从程序的一个部分传递到另一个部分的途径。
3 个组成部分：
- 引发异常
- 使用处理程序捕获异常
- 使用 try 块。

[C++ 异常处理 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-exceptions-handling.html)

C++ 异常处理涉及到三个关键字：`try`、`catch`、`throw`。
-  `throw` : 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。
- `catch`: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。
- `try`: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。
```cpp
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

### 栈解退


---


# string 类和标准模板库

## `string` 类

由头文件 `string` 支持。
### 构造函数

`string` 实际上是模板具体化 `basic_string<char>` 的一个 `typedef`，同时省略了内存管理的相关参数。
`size_type` 是一个依赖于实现的整形，在头文件 `string` 中被定义。
`string::npos` 定义为字符串的最大长度，通常为 `unsigned int` 的最大值。
`NBTS` 表示传统的 C 风格字符串。


| 构造函数                                                          | 描述                                                                                                                               |
| ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `string(const char*s)`                                            | 将 `string` 对象初始化为 s 指向的 NBTS                                                                                             |
| `string(size_type n,char c)`                                      | 创建一个包含 n 个元素的 `string` 对象，其中每个元素都被初始化为字符 c                                                              |
| string (const string & str)                                       | 将一个 string 对象初始化为 string 对象 str（复制构造函数）                                                                         |
| string ()                                                         | 创建一个默认的 string 独享，长度为 0（默认构造函数）                                                                               |
| string (const char * s , size_type n)                             | 将 string 对象初始化为 s 指向的 NBTS 的前 n 个字符，即使超过了 NBTS 结尾                                                           |
| `template <class Iter>  string (Iter begin, Iter end)`              | 将 string 对象初始化为区间[begin，end) 内的字符，其中 begin 和 end 的行为就像指针，用于指定位置，范围包括 begin 在内，但不包括 end |
|  `string (const string & str , size_type pos = 0, size_type n npos)` | 将一个 string 对象初始化为 string 对象 str，并可能修改 str（移动构造函数）                                                         |
| `string (string&&str) noexcept`                                     | C++11 新增，他将一个 string 都西昂初始化为 string 对象 str，并可能修改 str（移动构造函数）                                         |
| `string(initializer_list<char> il)`                                 | C++11新增，他将一个string对象初始化为初始化列表il中的字符                                                                                                                                   |


## 泛型编程


### 序列容器类型

#### `vector`

头文件：`vector`



---
# 模板类
## `valarray` 类
由头文件`valarray`支持。

## vector

## array

## 库函数
### Cctype





