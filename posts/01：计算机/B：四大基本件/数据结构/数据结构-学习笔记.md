# 绪论
## 算法时间复杂度
     一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记作：
	T(n) = O(f(n))
	它随问题规模n的增大，算法执行时间的增长率个f(n)的增长率相同，称算法的渐进时间复杂度，简称时间复杂度
### 大O记号
用大写O()来体现算法时间复杂度的记法，我们称为==大O()记法==
==大O记号==：T（n） = O（f（n）)
![[Pasted image 20220409142801.png]]
![[Pasted image 20220409142957.png]]
### 常见函数复杂度
1. O(1)  常数阶一段代码不含转向（循环、调用、递归等）必顺序执行，既是O(1)
2. O($log^cn$)  对数阶
   - 对数O(logn):lnn | lgn | $log_{100}n$| | $log_{2012}n$
   - 常底数无所谓。
   - 常数次幂无所谓。
   - 这类算法非常有效，复杂度无线接近于常数
3. O($n^c$)
4. O(n)  线性阶
5. O($2^n$)：这类算法的计算成本增长极快，通常被认为不可忍受。从O($n^c$)到O($2^n$)是从有效算法到无效算法的分水岭
## 算法分析
两个主要任务 = 正确性（不变性 × 单调性 ） + 复杂度
不必为确定复杂度二将算法描述转化为RAM的基本指令再统计累积的指令次数。
C++等高级语言的基本指令，均等效于==常数==条RAM的基本指令；在渐进意义上，而这大体相当。
	分支转向：goto
	迭代循环：for()、while()、...
	调用+递归（自我调用）
复杂度分析主要方法：
- 迭代：级数求和
- 递归：递归跟踪+递归方程
- 猜测+验证
### 级数
==算术级数==：与末项平方同阶
==幂方级数==：比幂次高出一阶
![[Pasted image 20220409194403.png]]
==几何级数（a>1)==:与末项同阶
![[Pasted image 20220409194532.png]]
==收敛级数==
![[Pasted image 20220409194639.png]]
### 实例：
1. 取非极端元素

![[Pasted image 20220409202706.png]]
2. 起泡排序
   ![[Pasted image 20220409204629.png]]
   ![[Pasted image 20220409211617.png]]
   ### 封底估算
   ### 减而治之
   ![[Pasted image 20220410103008.png]]
   #### 数组求和：线性递归
   递归跟踪分析：检查每个==递归实例==，累计所需时间（调用语句本身，计入对应的子实例），其总和即总和即算法执行时间。
   ![[Pasted image 20220410103605.png]]
   调用的递归实例都可以线性的排列成上图所示的关系。
   递归追踪：直观形象，仅适用于简明的递归模式。
   递推方程：间接抽象，更设用于复杂的递归模式。
   ![[Pasted image 20220410112436.png]]
   #### 数组倒置
   ![[Pasted image 20220410113038.png]]
   上述算法也是减而治之的实例。 
   ![[Pasted image 20220410113320.png]]
   ### 分而治之
   ![[Pasted image 20220410114128.png]]
   #### 数组求和：二分递归
   ![[Pasted image 20220410121712.png]]
![[Pasted image 20220410123305.png]]
![[Pasted image 20220410125223.png]]
![[Pasted image 20220410125300.png]]
#### max2:迭代1
![[Pasted image 20220410152751.png]]
## 动态规划
