# 代码编译
## **编译器**
### 定义
编译器，是一个根据**源代码**生成**机器码**的程序。

### 编译器种类：
| 厂商 | C     | C++     | Fortran  |
| ---- | ----- | ------- | -------- |
| GNU  | gcc   | g++     | gfortran |
| LLVM | clang | clang++ | flang    |
## **多文件编译与链接：**
单文件编译虽然方便，但也有如下缺点：
- 所有的代码都堆在一起，不利于模块化和理解。
- 工程变大时，编译时间变得很长，改动一个地方就得全部重新编译。
因此，我们提出多文件编译的概念，文件之间通过符号声明相互引用。
> 详细的教程可参考：[基于VSCode和CMake实现C/C++开发 | Linux篇_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.337.search-card.all.click&vd_source=8e43b8da5e07eef6f57edcd950d3b1d3)

## **构建系统**
### 为什么有构建系统（Makefile）

文件越来越多时，一个个调用g++编译链接会变得很麻烦。
于是，发明了 make 这个程序，你只需写出不同文件之间的依赖关系，和生成各文件的规则。
和直接用一个脚本写出完整的构建过程相比，make 指明依赖关系的**好处：**
1. 当更新了hello.cpp时只会重新编译hello.o，而不需要把main.o也重新编译一遍。
能够自动并行地发起对hello.cpp和main.cpp的编译，加快编译速度（make -j）。
2. 用通配符批量生成构建规则，避免针对每个.cpp和.o重复写 g++ 命令（%.o: %.cpp）。
但**坏处**也很明显：
1. make 在 Unix 类系统上是通用的，但在 Windows 则不然。
2. 需要准确地指明每个项目之间的依赖关系，有头文件时特别头疼。
3. make 的语法非常简单，不像 shell 或 python 可以做很多判断等。
4. 不同的编译器有不同的 flag 规则，为 g++ 准备的参数可能对 MSVC 不适用。

### 构建系统的构建系统（CMake）

为了解决 make 的以上问题，跨平台的 CMake 应运而生。
1. 只需要写一份 CMakeLists.txt，他就能够在调用时生成当前系统所支持的构建系统。
1. CMake 可以自动检测源文件和头文件之间的依赖关系，导出到 Makefile 里。
1. CMake 具有相对高级的语法，内置的函数能够处理 configure，install 等常见需求。
1. CMake 可以自动检测当前的编译器，需要添加哪些 flag。比如 OpenMP，只需要在 CMakeLists.txt 中指明 target_link_libraries(a.out OpenMP::OpenMP_CXX) 即可。

### CMake的命令行调用

## **库（`library`）**

### 为什么需要库

- 有时候我们会有多个可执行文件，他们之间用到的某些功能是相同的，我们想把这些共用的功能做成一个库，方便大家一起共享。
- 库中的函数可以被可执行文件调用，也可以被其他库文件调用。
- 库文件又分为**静态库文件**和**动态库文件**。
- 其中静态库相当于直接把代码插入到生成的可执行文件中，会导致体积变大，但是只需要一个文件即可运行。
- 而动态库则只在生成的可执行文件中生成“插桩”函数，当可执行文件被加载时会读取指定目录中的.dll文件，加载到内存中空闲的位置，并且替换相应的“插桩”指向的地址为加载后的地址，这个过程称为重定向。这样以后函数被调用就会跳转到动态加载的地址去。
- 查找目录：
	- Windows：可执行文件同目录，其次是环境变量%PATH%
	- Linux：ELF格式可执行文件的RPATH，其次是/usr/lib等

### CMake 中的静态库与动态库

 - CMake 除了 `add_executable` 可以生成可执行文件外，还可以通过 `add_library` 生成库文件。
 - `add_library` 的语法与 `add_executable` 大致相同，除了他需要指定是动态库还是静态库：
	- 静态库:	 
	  ``` cmake
	  add_library(test STATIC source1.cpp source2.cpp)  # 生成静态库 libtest.a
	  ```
	- 动态库
	  ``` cmake
	  add_library(test SHARED source1.cpp source2.cpp)  # 生成动态库 libtest.so
	  ```
- 动态库有很多坑，特别是 Windows 环境下，初学者自己创建库时，建议使用静态库。
- 但是他人提供的库，大多是作为动态库的，我们之后会讨论如何使用他人的库。
- 创建库以后，要在某个可执行文件中使用该库，只需要：
	``` cmake
	target_link_libraries(myexec PUBLIC test)  # 为 myexec 链接刚刚制作的库 libtest.a
	```
	
- 其中 PUBLIC 的含义稍后会说明（CMake 中有很多这样的大写修饰符）
# C++ 语法
## **为什么 C++ 需要声明**
- 在多文件编译章中，说到了需要在 main.cpp 声明 hello() 才能引用。为什么？
- 因为需要知道函数的参数和返回值类型：这样才能支持重载，隐式类型转换等特性。例如 show(3)，如果声明了 void show(float x)，那么编译器知道把 3 转换成 3.0f 才能调用。
- 让编译器知道 hello 这个名字是一个函数，不是一个变量或者类的名字：这样当我写下 hello() 的时候，他知道我是想调用 hello 这个函数，而不是创建一个叫 hello 的类的对象。
- 其实，C++ 是一种强烈依赖上下文信息的编程语言，举个例子：
	```cpp
	vector < MyClass > a;   // 声明一个由 MyClass 组成的数组
	```
- 如果编译器不知道 `vector` 是个模板类，那他完全可以把 `vector` 看做一个变量名，把 `<` 解释为小于号，从而理解成判断 `vector` 这个变量的值是否小于`MyClass`这个变量的值。
正因如此，我们常常可以在 C++ 代码中看见这样的写法：
```cpp
typename decay<T>::type
```
因为 T 是不确定的，导致编译器无法确定 `decay<T>` 的 `type` 是一个类型，还是一个值。因此用 typename 修饰来让编译器确信这是一个类型名

## **C++头文件**

为了使用 hello 这个函数，我们刚才在 main.cpp 里声明了 void hello() 。
但是如果另一个文件 other.cpp 也需要用 hello 这个函数呢？也在里面声明一遍？
如果能够只写一遍，然后自动插入到需要用 hello 的那些 .cpp 里就好了……
后来，这个编译前替换的步骤逐渐变成编译器的了一部分，称为预处理阶段，`#define` 定义的宏也是这个阶段处理的。
此外，在实现的文件 hello.cpp 中导入声明的文件 hello.h 是个好习惯，可以保证当 hello.cpp 被修改时，比如改成 hello(int)，编译器能够发现 hello.h 声明的 hello() 和定义的 hello(int) 不一样，避免“沉默的错误”。
实际上 cstdio 也无非是提供了 printf 等一系列函数声明的头文件而已，实际的实现是在 libc.so 这个动态库里。
在引入头文件时，不同形式的区别。
- `<cstdio>` 这种形式表示不要在当前目录下搜索，**只在系统目录里搜索**。
- `"hello.h"` 这种形式则**优先搜索当前目录**下有没有这个文件，找不到再搜索系统目录.
- **注意：** 用`<>`的地方不能用`""`，但用`""`的地方不能用`<>`

## **头文件进阶 - 递归地使用头文件**

但若重复地导入头文件容易造成“菱形引用”。
**解决方法：**
在头文件前面加上一行：
```cpp
#pragma once
```

这样当预处理器第二次读到同一个文件时，就会自动跳过.
通常头文件都不想被重复导入，因此建议在每个头文件前加上这句话

