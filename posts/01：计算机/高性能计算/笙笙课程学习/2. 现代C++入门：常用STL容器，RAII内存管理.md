# 构造函数
- 在调用构造函数时，常用 `{}` 而不是 `()` 
- 默认构造函数是为了兼容 C 语言
	- 默认构造函数会有一个陷阱。由于隐式转换引起。可以由 `explicit` 解决
## `explicit` 的妙用

### 构造函数为单参数时
>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：
>``` cpp
>Classname object = value;
> ```
> 这样的转换有可能会导致很严重的问题

可以在构造函数前添加 `explicit` 关键字解决。

- 避免陷阱体现在哪里？
	- 加了 `explicit` 表示必须用 () 强制转换。
	- `Classname object = value;` 就会导致编译不通过。
	- 同理 `classname(int_type_value)` 也会报错。
		- 注意 `classname(int_type_value)` 与 `classname({int_type_value})` 等价。
### 构造函数为多参数时

explicit 对多个参数也起作用！

多个参数时，explicit 的作用体现在禁止从一个 {} 表达式初始化。
如果你希望在一个返回 Pig 的函数里用：
``` cpp
return {“佩奇”, 80};
```
的话，就不要加 `explicit` 关键字。

## 使用 `{}` 和 `()` 调用构造参数的区别
1. int (3.14f) 不会出错，但是 int{3.14f} 会出错，因为 {} 是非强制转换。
1. Pig (“佩奇”, 3.14f) 不会出错，但是 Pig{“佩奇”, 3.14f} 会出错，原因同上，更安全。
1. 可读性：Pig (1, 2) 则 Pig 有可能是个函数，Pig{1, 2} 看起来更明确。

## `default ` 与 `delete`
- 程序员声明了自定义构造函数之后，若还想让编译器生成默认构造函数
	 - `clas() = default`
	 - 但是初始化列表不能通过这个办法来恢复。
- 不想让编译器自动生成拷贝构造函数：= delete 语法
	- =delete 和 = default 是一对
	- 如果不确定某个函数是否被默认声明可以用这两个语法显式地声明一下
- 除非是智能指针，否则实现都用深拷贝
	-  操作：有些类就会删除拷贝构造函数，让智能指针管理这个类，这样这个类就变成智能指针的浅拷贝，从而节约时间。
	- 拷贝函数默认是浅拷贝
	- 浅拷贝有可能会导致双重 free

![[Pasted image 20230114223614.png]]
- 要区分**移动**和**拷贝**
	- 时间复杂度
	- std:: move 实现移动
	- 移动之后原本的被移动的会被**清空**。因此要注意使用场景
- 移动进阶：交换两者的值
	- 通过：`std::swap`
	- `swap` 在高性能计算中被用来实现双缓存（ping pong buffer）
	- 善用移动和交换可以使代码的复杂度变低。
- 要注意**移动**和**拷贝**的应用场景
	- 调用移动
		- 作为返回值
		- 就地构造的类
		- 显式地移动
	- 调用拷贝
		- 显式的拷贝
			- 在返回时调用拷贝：
			  ``` cpp
			return std::as_const(v2)
			```

		- 默认拷贝
	- 单独使用 `move` 和 ` as_const ` 语句没有任何作用
		- 需要清空：`v2 = {}` 或者 `v2.clear()`
		- 需要拷贝：`{auto_(指的是变量名) = v2}`
	- 这两个函数只是负责类型转换，实际产生移动、拷贝效果的是在类里的构造、赋值函数里
	- 如果有移动赋值函数可以删除拷贝赋值函数

# 智能指针

- `unique_ptr` 禁止拷贝
	- 如果允许拷贝就会出现重复释放的问题
	- 函数参数禁止拷贝解决方案：
	1. func () 不需要夺走资源的占用权。
	   - 获取原始指针
	2. `unique_ptr` 禁止拷贝，但可以移动
	   - 此时 func () 需要夺走资源的占用权，因此需要接过掌管对象生命周期的大权
	   - 通过 `std::move`
	   - 移交之后仍希望访问原指针指向的对象
		   - 解决方案：提前获取原始指针。
			   - 在移交控制权给 func 之前提前通过 `p.get()` 获取原始指针
			   - 需要注意的是此方法获取的指针在使用之前不会被清除。
			   - 即获取的原始指针的生命周期不能超过被获取的智能指针的生命周期
			   - 否则就会出现空悬指针
- `shared_ptr` : 更智能的指针
	- 文档： [std::shared_ptr - cppreference.com](https://zh.cppreference.com/w/cpp/memory/shared_ptr)
	- 缺点：
		1. shared_ptr需要维护一个`atomic`的引用计数器，效率低，需要额外的一块管理内存，访问实际对象需要二级指针，而且`delete`使用了**类型擦除**技术
		2. 全部使用 `shared_ptr`，可能会出现**循环引用**之类的问题，导致内存泄漏，依然需要使用不影响技术的原始指针或者 `weak_ptr` 来避免。
		3. 循环引用示例：![image.png](https://growlr-center-blog-image.oss-cn-beijing.aliyuncs.com/image/20230115235354.png)

	- 循环引用：解决方法
		1. 只需要把其中逻辑上“不具有所属权”的那一个改成 `weak_ptr` 即可
		   - 代码示例：![image.png](https://growlr-center-blog-image.oss-cn-beijing.aliyuncs.com/image/20230115235517.png)
		2. 将其中的逻辑上具备所有权的那一个改成原始指针。
		   - 当两个都为 `shared_ptr`，需要建立循环引用关系时。
			- 代码示例： ![[Pasted image 20230115234832.png]]
		   - 此时也可以改成 `unique_ptr`，此时就不需要 shared_ptr 维护一个原子计数器的开销了。
		   - 代码示例：![[Pasted image 20230115235028.png]]
- 不影响`shared_ptr`计数：弱引用`weak_ptr`
	- 有时候我们希望维护一个`shared_ptr`的**弱引用**`weak_ptr`，即：弱引用的拷贝与解构不影响其引用计数器。
	- 之后有需要时，可以通过`lock()`随机产生一个新的`shared_ptr`作为强引用。但不`lock`的时候不影响计数。
	- 如果失效（计数器归零）则`expired()`会返回`false`，且`lock()`也会返回`nullptr`。
	- 这是最关键的一点，`weak_ptr`能提供**失效检测**，更安全。

### 生命周期

- shared_ptr 管理的对象生命周期，取决于所有引用中，最长寿的那一个。
- unique_ptr 管理的对象生命周期长度，取决于他所属的唯一一个引用的寿命

## 作为类的成员变量

可以在类中使用智能指针作为成员变量。需要根据实际情况 (主要是看所有权)，判断要用哪一种智能指针:
1. unique_ptr：**当该对象仅仅属于我时**。比如：父窗口中指向子窗口的指针。
1. 原始指针：**当该对象不属于我，但他释放前我必然被释放时**。有一定风险。比如：子窗口中指向父窗口的指针。
1. shared_ptr：**当该对象由多个对象共享时，或虽然该对象仅仅属于我，但有使用 weak_ptr 的需要。**
	- 共享的指针是共享所有权。
1. weak_ptr：**当该对象不属于我，且他释放后我仍可能不被释放时**。比如：指向窗口中上一次被点击的元素。
1. 初学者可以多用 shared_ptr 和 weak_ptr 的组合，更安全。

通常 shared_ptr 和 weak_ptr 一起用，原始指针和 `unique_ptr` 一起用。
- 因为 `unique_ptr` 不能生成一个 `weak_ptr`，只能生成原始指针
- `shared_ptr` 能生成 `weak_ptr`。
- 原始指针没有失效检测

**注意：** C++中所有对象都是深拷贝，唯有 `shared_ptr` 和 `weak_ptr` 是浅拷贝，而 `unique_ptr` 则是直接禁止拷贝。
所以智能指针解决了对象不能浅拷贝的问题，比如窗口是不需要深拷贝的，他需要的是浅拷贝，这时就可以将窗口类的拷贝构造函数给统一禁用掉，而使用 `shared_ptr <窗口>` 来管理，这样就可以把比较麻烦的深拷贝语义转换为智能指针的浅拷贝了。